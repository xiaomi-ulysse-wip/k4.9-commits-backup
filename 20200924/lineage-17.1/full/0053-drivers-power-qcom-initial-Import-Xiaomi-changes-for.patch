From 6408f4568d39695329b0926c115a8b200f71f1ad Mon Sep 17 00:00:00 2001
From: nayefhaidir <nayefhaydir@gmail.com>
Date: Sun, 24 Mar 2019 17:03:13 +0700
Subject: [PATCH 53/99] drivers: power: qcom: initial Import Xiaomi changes for
 ulysse

Signed-off-by: soekarnohatta <nayefhaidir@outlook.co.id>
---
 drivers/power/reset/msm-poweroff.c            |    9 +-
 drivers/power/supply/qcom/Kconfig             |   18 +
 drivers/power/supply/qcom/Makefile            |    2 +
 drivers/power/supply/qcom/bq2560x.h           |   69 +
 drivers/power/supply/qcom/bq2560x_charger.c   | 2542 +++++++++++++++++
 drivers/power/supply/qcom/bq2560x_reg.h       |  307 ++
 drivers/power/supply/qcom/bq27426_fg.c        | 2213 ++++++++++++++
 .../power/supply/qcom/bq27426_gmfs_coslight.h |  971 +++++++
 drivers/power/supply/qcom/bq27426_gmfs_scud.h |  970 +++++++
 drivers/power/supply/qcom/bq27426_gmfs_sdi.h  |  971 +++++++
 .../power/supply/qcom/bq27426_gmfs_sunwoda.h  |  971 +++++++
 drivers/power/supply/qcom/bqfs_cmd_type.h     |   37 +
 drivers/power/supply/qcom/qpnp-fg.c           |   81 +-
 drivers/power/supply/qcom/qpnp-smbcharger.c   |  172 +-
 drivers/power/supply/qcom/qpnp-typec.c        |   90 +
 15 files changed, 9403 insertions(+), 20 deletions(-)
 create mode 100644 drivers/power/supply/qcom/bq2560x.h
 create mode 100644 drivers/power/supply/qcom/bq2560x_charger.c
 create mode 100644 drivers/power/supply/qcom/bq2560x_reg.h
 create mode 100644 drivers/power/supply/qcom/bq27426_fg.c
 create mode 100644 drivers/power/supply/qcom/bq27426_gmfs_coslight.h
 create mode 100644 drivers/power/supply/qcom/bq27426_gmfs_scud.h
 create mode 100644 drivers/power/supply/qcom/bq27426_gmfs_sdi.h
 create mode 100644 drivers/power/supply/qcom/bq27426_gmfs_sunwoda.h
 create mode 100644 drivers/power/supply/qcom/bqfs_cmd_type.h

diff --git a/drivers/power/reset/msm-poweroff.c b/drivers/power/reset/msm-poweroff.c
index 28792c292f8e..661a4c50fd8d 100644
--- a/drivers/power/reset/msm-poweroff.c
+++ b/drivers/power/reset/msm-poweroff.c
@@ -64,7 +64,7 @@ static bool force_warm_reboot;
  * There is no API from TZ to re-enable the registers.
  * So the SDI cannot be re-enabled when it already by-passed.
  */
-static int download_mode = 1;
+static int download_mode = 0;
 #else
 static const int download_mode;
 #endif
@@ -312,7 +312,9 @@ static void msm_restart_prepare(const char *cmd)
 	else
 		qpnp_pon_system_pwr_off(PON_POWER_OFF_HARD_RESET);
 
-	if (cmd != NULL) {
+	if (in_panic) {
+		qpnp_pon_system_pwr_off(PON_POWER_OFF_WARM_RESET);
+	} else if (cmd != NULL) {
 		if (!strncmp(cmd, "bootloader", 10)) {
 			qpnp_pon_set_restart_reason(
 				PON_RESTART_REASON_BOOTLOADER);
@@ -363,7 +365,10 @@ static void msm_restart_prepare(const char *cmd)
 					     restart_reason);
 			}
 		} else if (!strncmp(cmd, "edl", 3)) {
+			if(0)
 			enable_emergency_dload_mode();
+			else
+			pr_info("This command already been disabled");
 		} else {
 			__raw_writel(0x77665501, restart_reason);
 		}
diff --git a/drivers/power/supply/qcom/Kconfig b/drivers/power/supply/qcom/Kconfig
index 1c8f1166a7fa..0b688d5056d1 100644
--- a/drivers/power/supply/qcom/Kconfig
+++ b/drivers/power/supply/qcom/Kconfig
@@ -163,4 +163,22 @@ config SMB1390_CHARGE_PUMP
 	  SMB1390 is a div2 charge pump capable of delivering 6A charge current
 	  with very high efficiency.
 
+config BQ2560X_CHARGER
+	tristate "bq2560x charger driver"
+	depends on I2C
+	help
+	  Say Y to include support
+	  for bq2560x charger gauge driver for batteries.
+	  This driver source code implemented
+	  all functions bq2560x charger.
+
+config BQ27426_FG
+	tristate "BQ27426 fuel gauge driver"
+	depends on I2C
+	help
+	  Say Y to include support
+	  for BQ27426 fuel gauge driver for batteries.
+	  This driver source code implemented
+	  all functions for BQ27426 fuel gauge.
+
 endmenu
diff --git a/drivers/power/supply/qcom/Makefile b/drivers/power/supply/qcom/Makefile
index ffc1ce3ecb95..85007103493e 100644
--- a/drivers/power/supply/qcom/Makefile
+++ b/drivers/power/supply/qcom/Makefile
@@ -14,3 +14,5 @@ obj-$(CONFIG_QPNP_SMB5)		+= step-chg-jeita.o battery.o qpnp-smb5.o smb5-lib.o pm
 obj-$(CONFIG_SMB1390_CHARGE_PUMP)	+= smb1390-charger.o pmic-voter.o
 obj-$(CONFIG_QPNP_VM_BMS) += qpnp-vm-bms.o batterydata-lib.o batterydata-interface.o
 obj-$(CONFIG_QPNP_LINEAR_CHARGER)	+= qpnp-linear-charger.o
+obj-$(CONFIG_BQ27426_FG)	+= bq27426_fg.o
+obj-$(CONFIG_BQ2560X_CHARGER)	+= bq2560x_charger.o
diff --git a/drivers/power/supply/qcom/bq2560x.h b/drivers/power/supply/qcom/bq2560x.h
new file mode 100644
index 000000000000..f1faa0ce05bf
--- /dev/null
+++ b/drivers/power/supply/qcom/bq2560x.h
@@ -0,0 +1,69 @@
+/*
+ * BQ2560x battery charging driver
+ *
+ * Copyright (C) 2013 Texas Instruments
+ * Copyright (C) 2018 XiaoMi, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#ifndef _LINUX_BQ2560X_I2C_H
+#define _LINUX_BQ2560X_I2C_H
+
+#include <linux/power_supply.h>
+
+
+struct bq2560x_charge_param {
+	int vlim;
+	int ilim;
+	int ichg;
+	int vreg;
+};
+
+enum stat_ctrl {
+	STAT_CTRL_STAT,
+	STAT_CTRL_ICHG,
+	STAT_CTRL_INDPM,
+	STAT_CTRL_DISABLE,
+};
+
+enum vboost {
+	BOOSTV_4850 = 4850,
+	BOOSTV_5000 = 5000,
+	BOOSTV_5150 = 5150,
+	BOOSTV_5300	= 5300,
+};
+
+enum iboost {
+	BOOSTI_500 = 500,
+	BOOSTI_1200 = 1200,
+};
+
+enum vac_ovp {
+	VAC_OVP_5500 = 5500,
+	VAC_OVP_6200 = 6200,
+	VAC_OVP_10500 = 10500,
+	VAC_OVP_14300 = 14300,
+};
+
+
+struct bq2560x_platform_data {
+	struct bq2560x_charge_param usb;
+	struct bq2560x_charge_param ta;
+	int iprechg;
+	int iterm;
+
+	enum stat_ctrl statctrl;
+	enum vboost boostv;
+	enum iboost boosti;
+	enum vac_ovp vac_ovp;
+
+};
+
+#endif
\ No newline at end of file
diff --git a/drivers/power/supply/qcom/bq2560x_charger.c b/drivers/power/supply/qcom/bq2560x_charger.c
new file mode 100644
index 000000000000..bc8be3d47c3d
--- /dev/null
+++ b/drivers/power/supply/qcom/bq2560x_charger.c
@@ -0,0 +1,2542 @@
+/*
+ * BQ2560x battery charging driver
+ *
+ * Copyright (C) 2013 Texas Instruments
+ * Copyright (C) 2018 XiaoMi, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ */
+
+#define pr_fmt(fmt)	"bq2560x: %s: " fmt, __func__
+
+#include <linux/gpio.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/power_supply.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/err.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/regulator/machine.h>
+#include <linux/debugfs.h>
+#include <linux/bitops.h>
+#include <linux/math64.h>
+#include <linux/alarmtimer.h>
+
+#include "bq2560x_reg.h"
+#include "bq2560x.h"
+
+#define THERMAL_CONFIG_FB 1
+#ifdef THERMAL_CONFIG_FB
+#include <linux/notifier.h>
+#include <linux/fb.h>
+#endif
+
+#if 1
+
+
+#undef pr_info
+#define pr_info pr_err
+
+
+#else
+#undef pr_info
+#define pr_info pr_debug
+#endif
+
+enum bq2560x_vbus_type {
+	BQ2560X_VBUS_NONE = REG08_VBUS_TYPE_NONE,
+	BQ2560X_VBUS_USB = REG08_VBUS_TYPE_USB,
+	BQ2560X_VBUS_ADAPTER = REG08_VBUS_TYPE_ADAPTER,
+	BQ2560X_VBUS_OTG = REG08_VBUS_TYPE_OTG,
+};
+
+enum bq2560x_part_no {
+	BQ25600 = 0x00,
+	BQ25601 = 0x02,
+};
+
+enum {
+	USER		= BIT(0),
+	JEITA		= BIT(1),
+	BATT_FC		= BIT(2),
+	BATT_PRES	= BIT(3),
+};
+
+enum wakeup_src {
+	WAKEUP_SRC_MONITOR = 0,
+	WAKEUP_SRC_JEITA,
+	WAKEUP_SRC_MAX,
+};
+
+#define WAKEUP_SRC_MASK (~(~0 << WAKEUP_SRC_MAX))
+struct bq2560x_wakeup_source {
+	struct wakeup_source source;
+	unsigned long enabled_bitmap;
+	spinlock_t ws_lock;
+};
+
+enum bq2560x_charge_state {
+	CHARGE_STATE_IDLE = REG08_CHRG_STAT_IDLE,
+	CHARGE_STATE_PRECHG = REG08_CHRG_STAT_PRECHG,
+	CHARGE_STATE_FASTCHG = REG08_CHRG_STAT_FASTCHG,
+	CHARGE_STATE_CHGDONE = REG08_CHRG_STAT_CHGDONE,
+};
+
+struct bq2560x_otg_regulator {
+	struct regulator_desc	rdesc;
+	struct regulator_dev	*rdev;
+};
+
+
+struct bq2560x {
+	struct device *dev;
+	struct i2c_client *client;
+
+	enum bq2560x_part_no part_no;
+	int	revision;
+
+	int gpio_ce;
+
+	int	vbus_type;
+
+	int status;
+
+	struct mutex data_lock;
+	struct mutex i2c_rw_lock;
+	struct mutex profile_change_lock;
+	struct mutex charging_disable_lock;
+	struct mutex irq_complete;
+
+	struct bq2560x_wakeup_source bq2560x_ws;
+
+	bool irq_waiting;
+	bool irq_disabled;
+	bool resume_completed;
+
+	bool batt_present;
+	bool usb_present;
+
+	bool batt_full;
+
+	bool charge_enabled;
+	bool otg_enabled;
+	bool batfet_enabled;
+	bool in_hiz;
+	bool dis_safety;
+
+	bool vindpm_triggered;
+	bool iindpm_triggered;
+
+	bool in_therm_regulation;
+	bool in_vsys_regulation;
+
+	bool power_good;
+	bool vbus_good;
+
+	bool topoff_active;
+	bool acov_triggered;
+
+	bool software_jeita_supported;
+	bool jeita_active;
+
+	bool batt_hot;
+	bool batt_cold;
+	bool batt_warm;
+	bool batt_cool;
+	bool batt_cool_xiaomi;
+
+	int batt_hot_degc;
+	int batt_warm_degc;
+	int batt_cool_degc;
+	int batt_cool_xiaomi_degc;
+	int batt_cold_degc;
+	int hot_temp_hysteresis;
+	int cold_temp_hysteresis;
+
+	int batt_cool_ma;
+	int batt_cool_xiaomi_ma;
+	int batt_warm_ma;
+	int batt_cool_mv;
+	int batt_warm_mv;
+
+
+	int batt_temp;
+
+	int jeita_ma;
+	int jeita_mv;
+
+	unsigned int thermal_levels;
+	unsigned int therm_lvl_sel;
+	unsigned int *thermal_mitigation;
+
+	int	usb_psy_ma;
+	int charge_state;
+	int charging_disabled_status;
+
+	int fault_status;
+
+	int skip_writes;
+	int	skip_reads;
+
+	struct bq2560x_platform_data* platform_data;
+
+	struct delayed_work discharge_jeita_work;
+	struct delayed_work charge_jeita_work;
+
+	struct alarm jeita_alarm;
+
+	struct dentry *debug_root;
+
+	struct bq2560x_otg_regulator otg_vreg;
+
+	struct power_supply *usb_psy;
+	struct power_supply *bms_psy;
+	struct power_supply batt_psy;
+	#ifdef THERMAL_CONFIG_FB
+	struct notifier_block notifier;
+	struct work_struct fb_notify_work;
+	unsigned int therm_lvl_reserved;
+	bool backlight_off;
+	#endif
+};
+
+static int BatteryTestStatus_enable = 0;
+#ifdef THERMAL_CONFIG_FB
+static int IsInCall = 0;
+static int LctThermal =0;
+#endif
+
+static int __bq2560x_read_reg(struct bq2560x* bq, u8 reg, u8 *data)
+{
+	s32 ret;
+
+	ret = i2c_smbus_read_byte_data(bq->client, reg);
+	if (ret < 0) {
+		pr_err("i2c read fail: can't read from reg 0x%02X\n", reg);
+		return ret;
+	}
+
+	*data = (u8)ret;
+
+	return 0;
+}
+
+static int __bq2560x_write_reg(struct bq2560x* bq, int reg, u8 val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_write_byte_data(bq->client, reg, val);
+	if (ret < 0) {
+		pr_err("i2c write fail: can't write 0x%02X to reg 0x%02X: %d\n",
+				val, reg, ret);
+		return ret;
+	}
+	return 0;
+}
+
+static int bq2560x_read_byte(struct bq2560x *bq, u8 *data, u8 reg)
+{
+	int ret;
+
+	if (bq->skip_reads) {
+		*data = 0;
+		return 0;
+	}
+
+	mutex_lock(&bq->i2c_rw_lock);
+	ret = __bq2560x_read_reg(bq, reg, data);
+	mutex_unlock(&bq->i2c_rw_lock);
+
+	return ret;
+}
+
+
+static int bq2560x_write_byte(struct bq2560x *bq, u8 reg, u8 data)
+{
+	int ret;
+
+	if (bq->skip_writes) {
+		return 0;
+	}
+
+	mutex_lock(&bq->i2c_rw_lock);
+	ret = __bq2560x_write_reg(bq, reg, data);
+	mutex_unlock(&bq->i2c_rw_lock);
+
+	if (ret) {
+		pr_err("Failed: reg=%02X, ret=%d\n", reg, ret);
+	}
+
+	return ret;
+}
+
+
+static int bq2560x_update_bits(struct bq2560x *bq, u8 reg,
+									u8 mask, u8 data)
+{
+	int ret;
+	u8 tmp;
+
+
+	if (bq->skip_reads || bq->skip_writes)
+		return 0;
+
+	mutex_lock(&bq->i2c_rw_lock);
+	ret = __bq2560x_read_reg(bq, reg, &tmp);
+	if (ret) {
+		pr_err("Failed: reg=%02X, ret=%d\n", reg, ret);
+		goto out;
+	}
+
+	tmp &= ~mask;
+	tmp |= data & mask;
+
+	ret = __bq2560x_write_reg(bq, reg, tmp);
+	if (ret) {
+		pr_err("Failed: reg=%02X, ret=%d\n", reg, ret);
+	}
+
+out:
+	mutex_unlock(&bq->i2c_rw_lock);
+	return ret;
+}
+static void bq2560x_stay_awake(struct bq2560x_wakeup_source *source,
+	enum wakeup_src wk_src)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&source->ws_lock, flags);
+
+	if (!__test_and_set_bit(wk_src, &source->enabled_bitmap)) {
+		__pm_stay_awake(&source->source);
+		pr_debug("enabled source %s, wakeup_src %d\n",
+			source->source.name, wk_src);
+	}
+	spin_unlock_irqrestore(&source->ws_lock, flags);
+}
+
+static void bq2560x_relax(struct bq2560x_wakeup_source *source,
+	enum wakeup_src wk_src)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&source->ws_lock, flags);
+	if (__test_and_clear_bit(wk_src, &source->enabled_bitmap) &&
+		!(source->enabled_bitmap & WAKEUP_SRC_MASK)) {
+		__pm_relax(&source->source);
+		pr_debug("disabled source %s\n", source->source.name);
+	}
+	spin_unlock_irqrestore(&source->ws_lock, flags);
+
+	pr_debug("relax source %s, wakeup_src %d\n",
+		source->source.name, wk_src);
+}
+
+static void bq2560x_wakeup_src_init(struct bq2560x *bq)
+{
+	spin_lock_init(&bq->bq2560x_ws.ws_lock);
+	wakeup_source_init(&bq->bq2560x_ws.source, "bq2560x");
+}
+
+
+
+static int bq2560x_enable_otg(struct bq2560x *bq)
+{
+	u8 val = REG01_OTG_ENABLE << REG01_OTG_CONFIG_SHIFT;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_01,
+							   REG01_OTG_CONFIG_MASK, val);
+
+}
+
+static int bq2560x_disable_otg(struct bq2560x *bq)
+{
+	u8 val = REG01_OTG_DISABLE << REG01_OTG_CONFIG_SHIFT;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_01,
+							   REG01_OTG_CONFIG_MASK, val);
+
+}
+
+static int bq2560x_enable_charger(struct bq2560x *bq)
+{
+	int ret;
+	u8 val = REG01_CHG_ENABLE << REG01_CHG_CONFIG_SHIFT;
+
+	ret = bq2560x_update_bits(bq, BQ2560X_REG_01, REG01_CHG_CONFIG_MASK, val);
+
+	return ret;
+}
+
+static int bq2560x_disable_charger(struct bq2560x *bq)
+{
+	int ret;
+	u8 val = REG01_CHG_DISABLE << REG01_CHG_CONFIG_SHIFT;
+
+	ret = bq2560x_update_bits(bq, BQ2560X_REG_01, REG01_CHG_CONFIG_MASK, val);
+	return ret;
+}
+
+int bq2560x_set_chargecurrent(struct bq2560x *bq, int curr)
+{
+	u8 ichg;
+
+	ichg = (curr - REG02_ICHG_BASE)/REG02_ICHG_LSB;
+	return bq2560x_update_bits(bq, BQ2560X_REG_02, REG02_ICHG_MASK,
+							ichg << REG02_ICHG_SHIFT);
+
+}
+
+int bq2560x_set_term_current(struct bq2560x *bq, int curr)
+{
+	u8 iterm;
+
+	iterm = (curr - REG03_ITERM_BASE) / REG03_ITERM_LSB;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_03, REG03_ITERM_MASK,
+							iterm << REG03_ITERM_SHIFT);
+}
+
+
+int bq2560x_set_prechg_current(struct bq2560x *bq, int curr)
+{
+	u8 iprechg;
+
+	iprechg = (curr - REG03_IPRECHG_BASE) / REG03_IPRECHG_LSB;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_03, REG03_IPRECHG_MASK,
+							iprechg << REG03_IPRECHG_SHIFT);
+}
+
+int bq2560x_set_chargevolt(struct bq2560x *bq, int volt)
+{
+	u8 val;
+
+	val = (volt - REG04_VREG_BASE)/REG04_VREG_LSB;
+	return bq2560x_update_bits(bq, BQ2560X_REG_04, REG04_VREG_MASK,
+							val << REG04_VREG_SHIFT);
+}
+
+
+int bq2560x_set_input_volt_limit(struct bq2560x *bq, int volt)
+{
+	u8 val;
+	val = (volt - REG06_VINDPM_BASE) / REG06_VINDPM_LSB;
+	return bq2560x_update_bits(bq, BQ2560X_REG_06, REG06_VINDPM_MASK,
+							val << REG06_VINDPM_SHIFT);
+}
+
+int bq2560x_set_input_current_limit(struct bq2560x *bq, int curr)
+{
+	u8 val;
+
+	val = (curr - REG00_IINLIM_BASE) / REG00_IINLIM_LSB;
+	return bq2560x_update_bits(bq, BQ2560X_REG_00, REG00_IINLIM_MASK,
+							val << REG00_IINLIM_SHIFT);
+}
+
+
+int bq2560x_set_watchdog_timer(struct bq2560x *bq, u8 timeout)
+{
+	u8 temp;
+
+	temp = (u8)(((timeout - REG05_WDT_BASE) / REG05_WDT_LSB) << REG05_WDT_SHIFT);
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_05, REG05_WDT_MASK, temp);
+}
+EXPORT_SYMBOL_GPL(bq2560x_set_watchdog_timer);
+
+int bq2560x_disable_watchdog_timer(struct bq2560x *bq)
+{
+	u8 val = REG05_WDT_DISABLE << REG05_WDT_SHIFT;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_05, REG05_WDT_MASK, val);
+}
+EXPORT_SYMBOL_GPL(bq2560x_disable_watchdog_timer);
+
+int bq2560x_reset_watchdog_timer(struct bq2560x *bq)
+{
+	u8 val = REG01_WDT_RESET << REG01_WDT_RESET_SHIFT;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_01, REG01_WDT_RESET_MASK, val);
+}
+EXPORT_SYMBOL_GPL(bq2560x_reset_watchdog_timer);
+
+int bq2560x_reset_chip(struct bq2560x *bq)
+{
+	int ret;
+	u8 val = REG0B_REG_RESET << REG0B_REG_RESET_SHIFT;
+
+	ret = bq2560x_update_bits(bq, BQ2560X_REG_0B, REG0B_REG_RESET_MASK, val);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(bq2560x_reset_chip);
+
+int bq2560x_enter_hiz_mode(struct bq2560x *bq)
+{
+	u8 val = REG00_HIZ_ENABLE << REG00_ENHIZ_SHIFT;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_00, REG00_ENHIZ_MASK, val);
+
+}
+EXPORT_SYMBOL_GPL(bq2560x_enter_hiz_mode);
+
+int bq2560x_exit_hiz_mode(struct bq2560x *bq)
+{
+
+	u8 val = REG00_HIZ_DISABLE << REG00_ENHIZ_SHIFT;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_00, REG00_ENHIZ_MASK, val);
+
+}
+EXPORT_SYMBOL_GPL(bq2560x_exit_hiz_mode);
+
+int bq2560x_get_hiz_mode(struct bq2560x *bq, u8 *state)
+{
+	u8 val;
+	int ret;
+
+	ret = bq2560x_read_byte(bq, &val, BQ2560X_REG_00);
+	if (ret)
+		return ret;
+	*state = (val & REG00_ENHIZ_MASK) >> REG00_ENHIZ_SHIFT;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(bq2560x_get_hiz_mode);
+
+
+static int bq2560x_enable_term(struct bq2560x* bq, bool enable)
+{
+	u8 val;
+	int ret;
+
+	if (enable)
+		val = REG05_TERM_ENABLE << REG05_EN_TERM_SHIFT;
+	else
+		val = REG05_TERM_DISABLE << REG05_EN_TERM_SHIFT;
+
+	ret = bq2560x_update_bits(bq, BQ2560X_REG_05, REG05_EN_TERM_MASK, val);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(bq2560x_enable_term);
+
+int bq2560x_set_boost_current(struct bq2560x *bq, int curr)
+{
+	u8 val;
+
+	val = REG02_BOOST_LIM_0P5A;
+	if (curr == BOOSTI_1200)
+		val = REG02_BOOST_LIM_1P2A;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_02, REG02_BOOST_LIM_MASK,
+							val << REG02_BOOST_LIM_SHIFT);
+}
+
+int bq2560x_set_boost_voltage(struct bq2560x *bq, int volt)
+{
+	u8 val;
+
+	if (volt == BOOSTV_4850)
+		val = REG06_BOOSTV_4P85V;
+	else if (volt == BOOSTV_5150)
+		val = REG06_BOOSTV_5P15V;
+	else if (volt == BOOSTV_5300)
+		val = REG06_BOOSTV_5P3V;
+	else
+		val = REG06_BOOSTV_5V;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_06, REG06_BOOSTV_MASK,
+							val << REG06_BOOSTV_SHIFT);
+}
+
+static int bq2560x_set_acovp_threshold(struct bq2560x *bq, int volt)
+{
+	u8 val;
+
+	if (volt == VAC_OVP_14300)
+		val = REG06_OVP_14P3V;
+	else if (volt == VAC_OVP_10500)
+		val = REG06_OVP_10P5V;
+	else if (volt == VAC_OVP_6200)
+		val = REG06_OVP_6P2V;
+	else
+		val = REG06_OVP_5P5V;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_06, REG06_OVP_MASK,
+							val << REG06_OVP_SHIFT);
+}
+
+
+static int bq2560x_set_stat_ctrl(struct bq2560x *bq, int ctrl)
+{
+	u8 val;
+
+	val = ctrl;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_00, REG00_STAT_CTRL_MASK,
+							val << REG00_STAT_CTRL_SHIFT);
+}
+
+
+static int bq2560x_set_int_mask(struct bq2560x *bq, int mask)
+{
+	u8 val;
+
+	val = mask;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_0A, REG0A_INT_MASK_MASK,
+							val << REG0A_INT_MASK_SHIFT);
+}
+
+
+static int bq2560x_enable_batfet(struct bq2560x *bq)
+{
+	const u8 val = REG07_BATFET_ON << REG07_BATFET_DIS_SHIFT;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_07, REG07_BATFET_DIS_MASK,
+								val);
+}
+EXPORT_SYMBOL_GPL(bq2560x_enable_batfet);
+
+
+static int bq2560x_disable_batfet(struct bq2560x *bq)
+{
+	const u8 val = REG07_BATFET_OFF << REG07_BATFET_DIS_SHIFT;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_07, REG07_BATFET_DIS_MASK,
+								val);
+}
+EXPORT_SYMBOL_GPL(bq2560x_disable_batfet);
+
+static int bq2560x_set_batfet_delay(struct bq2560x *bq, uint8_t delay)
+{
+	u8 val;
+
+	if (delay == 0)
+		val = REG07_BATFET_DLY_0S;
+	else
+		val = REG07_BATFET_DLY_10S;
+
+	val <<= REG07_BATFET_DLY_SHIFT;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_07, REG07_BATFET_DLY_MASK,
+								val);
+}
+EXPORT_SYMBOL_GPL(bq2560x_set_batfet_delay);
+
+static int bq2560x_set_vdpm_bat_track(struct bq2560x *bq)
+{
+	const u8 val = REG07_VDPM_BAT_TRACK_200MV << REG07_VDPM_BAT_TRACK_SHIFT;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_07, REG07_VDPM_BAT_TRACK_MASK,
+								val);
+}
+EXPORT_SYMBOL_GPL(bq2560x_set_vdpm_bat_track);
+
+static int bq2560x_enable_safety_timer(struct bq2560x *bq)
+{
+	const u8 val = REG05_CHG_TIMER_ENABLE << REG05_EN_TIMER_SHIFT;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_05, REG05_EN_TIMER_MASK,
+								val);
+}
+EXPORT_SYMBOL_GPL(bq2560x_enable_safety_timer);
+
+
+static int bq2560x_disable_safety_timer(struct bq2560x *bq)
+{
+	const u8 val = REG05_CHG_TIMER_DISABLE << REG05_EN_TIMER_SHIFT;
+
+	return bq2560x_update_bits(bq, BQ2560X_REG_05, REG05_EN_TIMER_MASK,
+								val);
+}
+EXPORT_SYMBOL_GPL(bq2560x_disable_safety_timer);
+
+static int bq2560x_charging_disable(struct bq2560x *bq, int reason,
+								int disable)
+{
+
+	int ret = 0;
+	int disabled;
+
+	mutex_lock(&bq->charging_disable_lock);
+
+	disabled = bq->charging_disabled_status;
+
+	pr_err("reason=%d requested_disable=%d disabled_status=%d\n",
+					reason, disable, disabled);
+
+	if (disable == true)
+		disabled |= reason;
+	else
+		disabled &= ~reason;
+
+	if (disabled && bq->charge_enabled)
+		ret = bq2560x_disable_charger(bq);
+	else if (!disabled && !bq->charge_enabled)
+		ret = bq2560x_enable_charger(bq);
+
+	if (ret) {
+		pr_err("Couldn't disable/enable charging for reason=%d ret=%d\n",
+							ret, reason);
+	} else {
+		bq->charging_disabled_status = disabled;
+		mutex_lock(&bq->data_lock);
+		bq->charge_enabled = !disabled;
+		mutex_unlock(&bq->data_lock);
+	}
+	mutex_unlock(&bq->charging_disable_lock);
+
+	return ret;
+}
+
+
+static struct power_supply *get_bms_psy(struct bq2560x *bq)
+{
+	if (bq->bms_psy)
+		return bq->bms_psy;
+	bq->bms_psy = power_supply_get_by_name("bms");
+	if (!bq->bms_psy)
+		pr_debug("bms power supply not found\n");
+
+	return bq->bms_psy;
+}
+
+static int bq2560x_get_batt_property(struct bq2560x *bq,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+	struct power_supply *bms_psy = get_bms_psy(bq);
+
+	int ret;
+
+	if (!bms_psy)
+		return -EINVAL;
+
+	ret = bms_psy->get_property(bms_psy, psp, val);
+
+	return ret;
+}
+
+static inline bool is_device_suspended(struct bq2560x *bq);
+static int bq2560x_get_prop_charge_type(struct bq2560x *bq)
+{
+	u8 val = 0;
+	if (is_device_suspended(bq))
+		return POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+
+	bq2560x_read_byte(bq, &val, BQ2560X_REG_08);
+	val &= REG08_CHRG_STAT_MASK;
+	val >>= REG08_CHRG_STAT_SHIFT;
+	switch (val) {
+	case CHARGE_STATE_FASTCHG:
+		return POWER_SUPPLY_CHARGE_TYPE_FAST;
+	case CHARGE_STATE_PRECHG:
+		return POWER_SUPPLY_CHARGE_TYPE_TRICKLE;
+	case CHARGE_STATE_CHGDONE:
+	case CHARGE_STATE_IDLE:
+		return POWER_SUPPLY_CHARGE_TYPE_NONE;
+	default:
+		return POWER_SUPPLY_CHARGE_TYPE_UNKNOWN;
+	}
+}
+
+static int bq2560x_get_prop_batt_present(struct bq2560x *bq)
+{
+	union power_supply_propval batt_prop = {0,};
+	int ret;
+
+	ret = bq2560x_get_batt_property(bq,
+					POWER_SUPPLY_PROP_PRESENT, &batt_prop);
+	if (!ret) {
+		mutex_lock(&bq->data_lock);
+		bq->batt_present = batt_prop.intval;
+		mutex_unlock(&bq->data_lock);
+	}
+	return ret;
+
+}
+
+static int bq2560x_get_prop_batt_full(struct bq2560x *bq)
+{
+	union power_supply_propval batt_prop = {0,};
+	int ret;
+
+	ret = bq2560x_get_batt_property(bq,
+					POWER_SUPPLY_PROP_STATUS, &batt_prop);
+	if (!ret) {
+		mutex_lock(&bq->data_lock);
+		bq->batt_full = (batt_prop.intval == POWER_SUPPLY_STATUS_FULL);
+		mutex_unlock(&bq->data_lock);
+	}
+	return ret;
+}
+
+static int bq2560x_get_prop_charge_status(struct bq2560x *bq)
+{
+	union power_supply_propval batt_prop = {0,};
+	int ret;
+	u8 status;
+
+	ret = bq2560x_get_batt_property(bq,
+					POWER_SUPPLY_PROP_STATUS, &batt_prop);
+	if (!ret && batt_prop.intval == POWER_SUPPLY_STATUS_FULL)
+		return POWER_SUPPLY_STATUS_FULL;
+
+	ret = bq2560x_read_byte(bq, &status, BQ2560X_REG_08);
+	if (ret) {
+		return 	POWER_SUPPLY_STATUS_UNKNOWN;
+	}
+
+	mutex_lock(&bq->data_lock);
+	bq->charge_state = (status & REG08_CHRG_STAT_MASK) >> REG08_CHRG_STAT_SHIFT;
+	mutex_unlock(&bq->data_lock);
+
+	switch(bq->charge_state) {
+	case CHARGE_STATE_FASTCHG:
+	case CHARGE_STATE_PRECHG:
+		return POWER_SUPPLY_STATUS_CHARGING;
+	case CHARGE_STATE_CHGDONE:
+		return POWER_SUPPLY_STATUS_NOT_CHARGING;
+	case CHARGE_STATE_IDLE:
+		return POWER_SUPPLY_STATUS_DISCHARGING;
+	default:
+		return 	POWER_SUPPLY_STATUS_UNKNOWN;
+	}
+
+}
+
+static int bq2560x_get_prop_health(struct bq2560x *bq)
+{
+	int ret;
+	union power_supply_propval batt_prop = {0,};
+
+	if (bq->software_jeita_supported) {
+		if (bq->jeita_active) {
+			if (bq->batt_hot)
+				ret = POWER_SUPPLY_HEALTH_OVERHEAT;
+			else if (bq->batt_warm)
+				ret = POWER_SUPPLY_HEALTH_WARM;
+			else if (bq->batt_cool || bq->batt_cool_xiaomi)
+				ret = POWER_SUPPLY_HEALTH_COOL;
+			else if (bq->batt_cold)
+				ret = POWER_SUPPLY_HEALTH_COLD;
+		} else {
+			ret = POWER_SUPPLY_HEALTH_GOOD;
+		}
+	} else {
+		ret = bq2560x_get_batt_property(bq,
+					POWER_SUPPLY_PROP_HEALTH, &batt_prop);
+		if (!ret)
+			ret = batt_prop.intval;
+		else
+			ret = POWER_SUPPLY_HEALTH_UNKNOWN;
+	}
+	return ret;
+}
+
+
+static enum power_supply_property bq2560x_charger_props[] = {
+
+	POWER_SUPPLY_PROP_CHARGE_TYPE,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_CHARGING_ENABLED,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
+
+	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
+	POWER_SUPPLY_PROP_TEMP,
+
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+
+
+
+	POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_RESISTANCE_ID,
+};
+
+static int bq2560x_charger_get_property(struct power_supply *psy,
+				enum power_supply_property psp,
+				union power_supply_propval *val)
+{
+
+	struct bq2560x *bq = container_of(psy, struct bq2560x, batt_psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CHARGE_TYPE:
+		val->intval = bq2560x_get_prop_charge_type(bq);
+		pr_debug("POWER_SUPPLY_PROP_CHARGE_TYPE:%d\n", val->intval);
+		break;
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		val->intval = bq->charge_enabled;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = 3080;
+		break;
+
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = bq2560x_get_prop_charge_status(bq);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = bq2560x_get_prop_health(bq);
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		bq2560x_get_batt_property(bq, psp, val);
+
+		break;
+	case POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL:
+		val->intval = bq->therm_lvl_sel;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
+	case POWER_SUPPLY_PROP_TEMP:
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+	case POWER_SUPPLY_PROP_RESISTANCE_ID:
+		return bq2560x_get_batt_property(bq, psp, val);
+	default:
+		return -EINVAL;
+
+	}
+
+	return 0;
+}
+
+static int bq2560x_system_temp_level_set(struct bq2560x *bq, int);
+
+static int bq2560x_charger_set_property(struct power_supply *psy,
+				       enum power_supply_property prop,
+				       const union power_supply_propval *val)
+{
+	struct bq2560x *bq = container_of(psy,
+				struct bq2560x, batt_psy);
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+		bq2560x_charging_disable(bq, USER, !val->intval);
+
+		power_supply_changed(&bq->batt_psy);
+		power_supply_changed(bq->usb_psy);
+		pr_info("POWER_SUPPLY_PROP_CHARGING_ENABLED: %s\n",
+						val->intval ? "enable" : "disable");
+		break;
+	case POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL:
+		bq2560x_system_temp_level_set(bq, val->intval);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int bq2560x_charger_is_writeable(struct power_supply *psy,
+				       enum power_supply_property prop)
+{
+	int ret;
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_CHARGING_ENABLED:
+	case POWER_SUPPLY_PROP_SYSTEM_TEMP_LEVEL:
+		ret = 1;
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+	return ret;
+}
+
+static int bq2560x_update_charging_profile(struct bq2560x *bq)
+{
+	int ret;
+	int chg_ma;
+	int chg_mv;
+	int icl;
+	int therm_ma;
+
+	union power_supply_propval prop = {0,};
+
+
+	if (!bq->usb_present)
+		return 0;
+
+	ret = bq->usb_psy->get_property(bq->usb_psy,
+							POWER_SUPPLY_PROP_TYPE, &prop);
+
+	if (ret < 0) {
+		pr_err("couldn't read USB TYPE property, ret=%d\n", ret);
+		return ret;
+	}
+	pr_err("charge type = %d\n", prop.intval);
+	mutex_lock(&bq->profile_change_lock);
+	if (bq->jeita_active) {
+		chg_ma = bq->jeita_ma;
+		chg_mv = bq->jeita_mv;
+	} else {
+		if (prop.intval == POWER_SUPPLY_TYPE_USB_DCP || prop.intval == POWER_SUPPLY_TYPE_USB_CDP) {
+			chg_ma = bq->platform_data->ta.ichg;
+			chg_mv = bq->platform_data->ta.vreg;
+		} else {
+			chg_ma = bq->platform_data->usb.ichg;
+			chg_mv = bq->platform_data->usb.vreg;
+		}
+	}
+
+	icl = bq->usb_psy_ma;
+	if (bq->usb_psy_ma < chg_ma) {
+		chg_ma = bq->usb_psy_ma;
+	}
+
+	if (bq->therm_lvl_sel > 0
+			&& bq->therm_lvl_sel < (bq->thermal_levels - 1))
+		therm_ma = bq->thermal_mitigation[bq->therm_lvl_sel];
+	else
+		therm_ma = chg_ma;
+
+	chg_ma = min(therm_ma, chg_ma);
+
+	pr_err("charge volt = %d, charge curr = %d, input curr limit = %d\n",
+				chg_mv, chg_ma, icl);
+
+	ret = bq2560x_set_input_current_limit(bq, icl);
+	if (ret < 0)
+		pr_err("couldn't set input current limit, ret=%d\n", ret);
+
+	ret = bq2560x_set_input_volt_limit(bq, bq->platform_data->ta.vlim);
+	if (ret < 0)
+		pr_err("couldn't set input voltage limit, ret=%d\n", ret);
+
+	ret = bq2560x_set_chargevolt(bq, chg_mv);
+	if (ret < 0)
+		pr_err("couldn't set charge voltage ret=%d\n", ret);
+
+	ret = bq2560x_set_chargecurrent(bq, chg_ma);
+	if (ret < 0)
+		pr_err("couldn't set charge current, ret=%d\n", ret);
+
+	mutex_unlock(&bq->profile_change_lock);
+
+	return 0;
+}
+
+
+static int bq2560x_system_temp_level_set(struct bq2560x *bq,
+							int lvl_sel)
+{
+	int ret = 0;
+	int prev_therm_lvl;
+
+	pr_err("%s lvl_sel=%d, bq->therm_lvl_sel = %d\n", __func__, lvl_sel, bq->therm_lvl_sel);
+	if (BatteryTestStatus_enable)
+		return 0;
+
+	if (!bq->thermal_mitigation) {
+		pr_err("Thermal mitigation not supported\n");
+		return -EINVAL;
+	}
+
+	if (lvl_sel < 0) {
+		pr_err("Unsupported level selected %d\n", lvl_sel);
+		return -EINVAL;
+	}
+
+	if (lvl_sel >= bq->thermal_levels) {
+		pr_err("Unsupported level selected %d forcing %d\n", lvl_sel,
+				bq->thermal_levels - 1);
+		lvl_sel = bq->thermal_levels - 1;
+	}
+
+	if (lvl_sel == bq->therm_lvl_sel)
+		return 0;
+
+	#ifdef THERMAL_CONFIG_FB
+	if (LctThermal == 0) {
+		bq->therm_lvl_reserved = lvl_sel;
+	}
+	if ((bq->backlight_off) && (IsInCall == 0) && (lvl_sel > 0)) {
+	    return 0;
+	}
+	pr_err("LctThermal=%d, bq->backlight_off= %d, IsInCall=%d\n", LctThermal, bq->backlight_off, IsInCall);
+	#endif
+
+
+	prev_therm_lvl = bq->therm_lvl_sel;
+	bq->therm_lvl_sel = lvl_sel;
+
+	ret = bq2560x_update_charging_profile(bq);
+	if (ret)
+			pr_err("Couldn't set USB current ret = %d\n", ret);
+
+
+	return ret;
+}
+
+
+static void bq2560x_external_power_changed(struct power_supply *psy)
+{
+	struct bq2560x *bq = container_of(psy, struct bq2560x, batt_psy);
+
+	union power_supply_propval prop = {0,};
+	int ret, current_limit = 0;
+
+
+	ret = bq->usb_psy->get_property(bq->usb_psy,
+								POWER_SUPPLY_PROP_CURRENT_MAX, &prop);
+	if (ret < 0)
+		pr_err("could not read USB current_max property, ret=%d\n", ret);
+	else
+		current_limit = prop.intval / 1000;
+
+	pr_err("current_limit = %d\n", current_limit);
+
+	if (bq->usb_psy_ma != current_limit) {
+		bq->usb_psy_ma = current_limit;
+		bq2560x_update_charging_profile(bq);
+	}
+
+	ret = bq->usb_psy->get_property(bq->usb_psy,
+								POWER_SUPPLY_PROP_ONLINE, &prop);
+	if (ret < 0)
+		pr_err("could not read USB ONLINE property, ret=%d\n", ret);
+	else
+		pr_info("usb online status =%d\n", prop.intval);
+
+	ret = 0;
+
+	if (bq->usb_present && (current_limit != 2)) {
+		if (prop.intval == 0) {
+			pr_err("set usb online\n");
+			ret = power_supply_set_online(bq->usb_psy, true);
+		}
+	} else {
+		if (prop.intval == 1) {
+			pr_err("set usb offline\n");
+			ret = power_supply_set_online(bq->usb_psy, false);
+		}
+	}
+
+	if (ret < 0)
+		pr_info("could not set usb online state, ret=%d\n", ret);
+
+}
+
+
+static int bq2560x_psy_register(struct bq2560x *bq)
+{
+	int ret;
+
+	bq->batt_psy.name = "battery";
+	bq->batt_psy.type = POWER_SUPPLY_TYPE_BATTERY;
+	bq->batt_psy.properties = bq2560x_charger_props;
+	bq->batt_psy.num_properties = ARRAY_SIZE(bq2560x_charger_props);
+	bq->batt_psy.get_property = bq2560x_charger_get_property;
+	bq->batt_psy.set_property = bq2560x_charger_set_property;
+	bq->batt_psy.external_power_changed = bq2560x_external_power_changed;
+	bq->batt_psy.property_is_writeable = bq2560x_charger_is_writeable;
+
+	ret = power_supply_register(bq->dev, &bq->batt_psy);
+	if (ret < 0) {
+		pr_err("failed to register batt_psy:%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void bq2560x_psy_unregister(struct bq2560x *bq)
+{
+	power_supply_unregister(&bq->batt_psy);
+}
+
+
+static int bq2560x_otg_regulator_enable(struct regulator_dev *rdev)
+{
+	int ret;
+	struct bq2560x *bq = rdev_get_drvdata(rdev);
+
+	ret = bq2560x_enable_otg(bq);
+	if (ret) {
+		pr_err("Couldn't enable OTG mode ret=%d\n", ret);
+	} else {
+		bq->otg_enabled = true;
+		pr_info("bq2560x OTG mode Enabled!\n");
+	}
+
+	return ret;
+}
+
+
+static int bq2560x_otg_regulator_disable(struct regulator_dev *rdev)
+{
+	int ret;
+	struct bq2560x *bq = rdev_get_drvdata(rdev);
+
+	ret = bq2560x_disable_otg(bq);
+	if (ret) {
+		pr_err("Couldn't disable OTG mode, ret=%d\n", ret);
+	} else {
+		bq->otg_enabled = false;
+		pr_info("bq2560x OTG mode Disabled\n");
+	}
+
+	return ret;
+}
+
+
+static int bq2560x_otg_regulator_is_enable(struct regulator_dev *rdev)
+{
+	int ret;
+	u8 status;
+	u8 enabled;
+	struct bq2560x *bq = rdev_get_drvdata(rdev);
+
+	ret = bq2560x_read_byte(bq, &status, BQ2560X_REG_01);
+	if (ret)
+		return ret;
+	enabled = ((status & REG01_OTG_CONFIG_MASK) >> REG01_OTG_CONFIG_SHIFT);
+
+	return (enabled == REG01_OTG_ENABLE) ? 1 : 0;
+
+}
+
+
+struct regulator_ops bq2560x_otg_reg_ops = {
+	.enable		= bq2560x_otg_regulator_enable,
+	.disable	= bq2560x_otg_regulator_disable,
+	.is_enabled = bq2560x_otg_regulator_is_enable,
+};
+
+static int bq2560x_regulator_init(struct bq2560x *bq)
+{
+	int ret = 0;
+	struct regulator_init_data *init_data;
+	struct regulator_config cfg = {};
+
+	init_data = of_get_regulator_init_data(bq->dev, bq->dev->of_node);
+	if (!init_data) {
+		dev_err(bq->dev, "Unable to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	if (init_data->constraints.name) {
+		bq->otg_vreg.rdesc.owner = THIS_MODULE;
+		bq->otg_vreg.rdesc.type = REGULATOR_VOLTAGE;
+		bq->otg_vreg.rdesc.ops = &bq2560x_otg_reg_ops;
+		bq->otg_vreg.rdesc.name = init_data->constraints.name;
+		pr_info("regualtor name = %s\n", bq->otg_vreg.rdesc.name);
+
+		cfg.dev = bq->dev;
+		cfg.init_data = init_data;
+		cfg.driver_data = bq;
+		cfg.of_node = bq->dev->of_node;
+
+		init_data->constraints.valid_ops_mask
+			|= REGULATOR_CHANGE_STATUS;
+
+		bq->otg_vreg.rdev = regulator_register(
+					&bq->otg_vreg.rdesc, &cfg);
+		if (IS_ERR(bq->otg_vreg.rdev)) {
+			ret = PTR_ERR(bq->otg_vreg.rdev);
+			bq->otg_vreg.rdev = NULL;
+			if (ret != -EPROBE_DEFER)
+				dev_err(bq->dev,
+					"OTG reg failed, rc=%d\n", ret);
+		}
+	}
+
+	return ret;
+}
+
+
+static int bq2560x_parse_jeita_dt(struct device *dev, struct bq2560x* bq)
+{
+	struct device_node *np = dev->of_node;
+	int ret;
+
+	ret = of_property_read_u32(np,"ti,bq2560x,jeita-hot-degc",
+						&bq->batt_hot_degc);
+	if(ret) {
+		pr_err("Failed to read ti,bq2560x,jeita-hot-degc\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,jeita-warm-degc",
+						&bq->batt_warm_degc);
+	if(ret) {
+		pr_err("Failed to read ti,bq2560x,jeita-warm-degc\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,jeita-cool-degc",
+						&bq->batt_cool_degc);
+	if(ret) {
+		pr_err("Failed to read ti,bq2560x,jeita-cool-degc\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,jeita-cool-xiaomi-degc",
+						&bq->batt_cool_xiaomi_degc);
+	if(ret) {
+		pr_err("Failed to read ti,bq2560x,jeita-cool-xiaomi-degc\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,jeita-cold-degc",
+						&bq->batt_cold_degc);
+	if(ret) {
+		pr_err("Failed to read ti,bq2560x,jeita-cold-degc\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,jeita-hot-hysteresis",
+						&bq->hot_temp_hysteresis);
+	if(ret) {
+		pr_err("Failed to read ti,bq2560x,jeita-hot-hysteresis\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,jeita-cold-hysteresis",
+						&bq->cold_temp_hysteresis);
+	if(ret) {
+		pr_err("Failed to read ti,bq2560x,jeita-cold-hysteresis\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,jeita-cool-ma",
+						&bq->batt_cool_ma);
+	if(ret) {
+		pr_err("Failed to read ti,bq2560x,jeita-cool-ma\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,jeita-cool-xiaomi-ma",
+						&bq->batt_cool_xiaomi_ma);
+	if(ret) {
+		pr_err("Failed to read ti,bq2560x,jeita-cool-xiaomi_ma\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,jeita-cool-mv",
+						&bq->batt_cool_mv);
+	if(ret) {
+		pr_err("Failed to read ti,bq2560x,jeita-cool-mv\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,jeita-warm-ma",
+						&bq->batt_warm_ma);
+	if(ret) {
+		pr_err("Failed to read ti,bq2560x,jeita-warm-ma\n");
+		return ret;
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,jeita-warm-mv",
+						&bq->batt_warm_mv);
+	if(ret) {
+		pr_err("Failed to read ti,bq2560x,jeita-warm-mv\n");
+		return ret;
+	}
+
+	bq->software_jeita_supported =
+		of_property_read_bool(np,"ti,bq2560x,software-jeita-supported");
+
+	return 0;
+}
+
+
+static struct bq2560x_platform_data* bq2560x_parse_dt(struct device *dev,
+													struct bq2560x * bq)
+{
+	int ret;
+	struct device_node *np = dev->of_node;
+	struct bq2560x_platform_data* pdata;
+
+	pdata = devm_kzalloc(dev, sizeof(struct bq2560x_platform_data),
+						GFP_KERNEL);
+	if (!pdata) {
+		pr_err("Out of memory\n");
+		return NULL;
+	}
+
+	ret = of_property_read_u32(np, "ti,bq2560x,chip-enable-gpio", &bq->gpio_ce);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,chip-enable-gpio\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,usb-vlim",&pdata->usb.vlim);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,usb-vlim\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,usb-ilim",&pdata->usb.ilim);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,usb-ilim\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,usb-vreg",&pdata->usb.vreg);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,usb-vreg\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,usb-ichg",&pdata->usb.ichg);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,usb-ichg\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,ta-vlim",&pdata->ta.vlim);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,ta-vlim\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,ta-ilim",&pdata->ta.ilim);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,ta-ilim\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,ta-vreg",&pdata->ta.vreg);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,ta-vreg\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,ta-ichg",&pdata->ta.ichg);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,ta-ichg\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,stat-pin-ctrl",&pdata->statctrl);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,stat-pin-ctrl\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,precharge-current",&pdata->iprechg);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,precharge-current\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,termination-current",&pdata->iterm);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,termination-current\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,boost-voltage",&pdata->boostv);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,boost-voltage\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,boost-current",&pdata->boosti);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,boost-current\n");
+	}
+
+	ret = of_property_read_u32(np,"ti,bq2560x,vac-ovp-threshold",&pdata->vac_ovp);
+	if(ret) {
+		pr_err("Failed to read node of ti,bq2560x,vac-ovp-threshold\n");
+	}
+
+	if (of_find_property(np, "qcom,thermal-mitigation",
+					&bq->thermal_levels)) {
+		bq->thermal_mitigation = devm_kzalloc(bq->dev,
+					bq->thermal_levels,
+						GFP_KERNEL);
+
+		if (bq->thermal_mitigation == NULL) {
+			pr_err("thermal mitigation kzalloc() failed.\n");
+
+		}
+
+		bq->thermal_levels /= sizeof(int);
+		ret = of_property_read_u32_array(np,
+				"qcom,thermal-mitigation",
+				bq->thermal_mitigation, bq->thermal_levels);
+		if (ret) {
+			pr_err("Couldn't read thermal limits ret = %d\n", ret);
+
+		}
+	}
+
+
+	return pdata;
+}
+
+
+static void bq2560x_init_jeita(struct bq2560x *bq)
+{
+
+	bq->batt_temp = -EINVAL;
+
+	bq->batt_hot_degc = 600;
+	bq->batt_warm_degc = 450;
+	bq->batt_cool_degc = 100;
+	bq->batt_cool_xiaomi_degc = 50;
+	bq->batt_cold_degc = 0;
+
+	bq->hot_temp_hysteresis = 50;
+	bq->cold_temp_hysteresis = 50;
+
+	bq->batt_cool_ma = 400;
+	bq->batt_cool_xiaomi_ma = 400;
+	bq->batt_cool_mv = 4100;
+	bq->batt_warm_ma = 400;
+	bq->batt_warm_mv = 4100;
+
+	bq->software_jeita_supported = true;
+
+
+	bq2560x_parse_jeita_dt(&bq->client->dev, bq);
+}
+
+static int bq2560x_init_device(struct bq2560x *bq)
+{
+	int ret;
+
+	bq2560x_disable_watchdog_timer(bq);
+
+	bq2560x_enable_batfet(bq);
+	bq2560x_set_vdpm_bat_track(bq);
+
+	ret = bq2560x_set_stat_ctrl(bq, bq->platform_data->statctrl);
+	if (ret)
+		pr_err("Failed to set stat pin control mode, ret = %d\n",ret);
+
+	ret = bq2560x_set_prechg_current(bq, bq->platform_data->iprechg);
+	if (ret)
+		pr_err("Failed to set prechg current, ret = %d\n",ret);
+
+	ret = bq2560x_set_term_current(bq, bq->platform_data->iterm);
+	if (ret)
+		pr_err("Failed to set termination current, ret = %d\n",ret);
+
+	ret = bq2560x_set_boost_voltage(bq, bq->platform_data->boostv);
+	if (ret)
+		pr_err("Failed to set boost voltage, ret = %d\n",ret);
+
+	ret = bq2560x_set_boost_current(bq, bq->platform_data->boosti);
+	if (ret)
+		pr_err("Failed to set boost current, ret = %d\n",ret);
+
+	ret = bq2560x_set_acovp_threshold(bq, bq->platform_data->vac_ovp);
+	if (ret)
+		pr_err("Failed to set acovp threshold, ret = %d\n",ret);
+
+	ret = bq2560x_set_int_mask(bq, REG0A_IINDPM_INT_MASK | REG0A_VINDPM_INT_MASK);
+	if (ret)
+		pr_err("Failed to set vindpm and iindpm int mask\n");
+
+	ret = bq2560x_enable_charger(bq);
+	if (ret) {
+		pr_err("Failed to enable charger, ret = %d\n",ret);
+	} else {
+		bq->charge_enabled = true;
+		pr_err("Charger Enabled Successfully!\n");
+	}
+
+	return 0;
+}
+
+
+static int bq2560x_detect_device(struct bq2560x* bq)
+{
+	int ret;
+	u8 data;
+
+	ret = bq2560x_read_byte(bq, &data, BQ2560X_REG_0B);
+	if(ret == 0) {
+		 bq->part_no = (data & REG0B_PN_MASK) >> REG0B_PN_SHIFT;
+		 bq->revision = (data & REG0B_DEV_REV_MASK) >> REG0B_DEV_REV_SHIFT;
+	}
+
+	return ret;
+}
+
+static void bq2560x_check_jeita(struct bq2560x *bq)
+{
+
+	int ret;
+	bool last_hot, last_warm, last_cool, last_cool_xiaomi, last_cold;
+	bool chg_disabled_jeita, jeita_hot_cold;
+	union power_supply_propval batt_prop = {0,};
+
+	ret = bq2560x_get_batt_property(bq,
+					POWER_SUPPLY_PROP_TEMP, &batt_prop);
+	if (!ret)
+		bq->batt_temp = batt_prop.intval;
+
+	if (bq->batt_temp == -EINVAL)
+		return;
+
+	last_hot = bq->batt_hot;
+	last_warm = bq->batt_warm;
+	last_cool = bq->batt_cool;
+	last_cool_xiaomi = bq->batt_cool_xiaomi;
+	last_cold = bq->batt_cold;
+
+	if (bq->batt_temp >= bq->batt_hot_degc) {
+		if (!bq->batt_hot) {
+			bq->batt_hot  = true;
+			bq->batt_warm = false;
+			bq->batt_cool = false;
+			bq->batt_cool_xiaomi = false;
+			bq->batt_cold = false;
+			bq->jeita_ma = 0;
+			bq->jeita_mv = 0;
+		}
+	} else if (bq->batt_temp >= bq->batt_warm_degc) {
+		if (!bq->batt_hot ||
+				(bq->batt_temp < bq->batt_hot_degc - bq->hot_temp_hysteresis)) {
+			bq->batt_hot  = false;
+			bq->batt_warm = true;
+			bq->batt_cool = false;
+			bq->batt_cool_xiaomi = false;
+			bq->batt_cold = false;
+			bq->jeita_mv = bq->batt_warm_mv;
+			bq->jeita_ma = bq->batt_warm_ma;
+		}
+	} else if (bq->batt_temp < bq->batt_cold_degc) {
+		if (!bq->batt_cold) {
+			bq->batt_hot  = false;
+			bq->batt_warm = false;
+			bq->batt_cool = false;
+			bq->batt_cool_xiaomi = false;
+			bq->batt_cold = true;
+			bq->jeita_ma = 0;
+			bq->jeita_mv = 0;
+		}
+	} else if (bq->batt_temp <= bq->batt_cool_xiaomi_degc) {
+		if (!bq->batt_cold ||
+				(bq->batt_temp > bq->batt_cold_degc + bq->cold_temp_hysteresis)) {
+			bq->batt_hot  = false;
+			bq->batt_warm = false;
+			bq->batt_cool = false;
+			bq->batt_cool_xiaomi = true;
+			bq->batt_cold = false;
+			bq->jeita_mv = bq->batt_cool_mv;
+			bq->jeita_ma = bq->batt_cool_xiaomi_ma;
+		}
+	} else if (bq->batt_temp < bq->batt_cool_degc) {
+		if (!bq->batt_cool) {
+			bq->batt_hot  = false;
+			bq->batt_warm = false;
+			bq->batt_cool = true;
+			bq->batt_cool_xiaomi = false;
+			bq->batt_cold = false;
+			bq->jeita_mv = bq->batt_cool_mv;
+			bq->jeita_ma = bq->batt_cool_ma;
+		}
+	} else {
+		bq->batt_hot  = false;
+		bq->batt_warm = false;
+		bq->batt_cool = false;
+		bq->batt_cool_xiaomi = false;
+		bq->batt_cold = false;
+	}
+
+	bq->jeita_active = bq->batt_cool || bq->batt_cool_xiaomi || bq->batt_hot ||
+					   bq->batt_cold || bq->batt_warm;
+
+	if ((last_cold != bq->batt_cold) || (last_warm != bq->batt_warm) ||
+		(last_cool != bq->batt_cool) || (last_cool_xiaomi != bq->batt_cool_xiaomi) ||(last_hot != bq->batt_hot)) {
+		bq2560x_update_charging_profile(bq);
+		power_supply_changed(&bq->batt_psy);
+		power_supply_changed(bq->usb_psy);
+	} else if (bq->batt_hot || bq->batt_cold) {
+		power_supply_changed(&bq->batt_psy);
+		power_supply_changed(bq->usb_psy);
+	}
+
+	jeita_hot_cold = bq->jeita_active && (bq->batt_hot || bq->batt_cold);
+	chg_disabled_jeita = !!(bq->charging_disabled_status & JEITA);
+	if (jeita_hot_cold != chg_disabled_jeita)
+		bq2560x_charging_disable(bq, JEITA, jeita_hot_cold);
+
+}
+
+static void bq2560x_check_batt_pres(struct bq2560x *bq)
+{
+	int ret = 0;
+	bool chg_disabled_pres;
+
+	ret = bq2560x_get_prop_batt_present(bq);
+	if (!ret) {
+		chg_disabled_pres = !!(bq->charging_disabled_status & BATT_PRES);
+		if (chg_disabled_pres != (!bq->batt_present)) {
+			ret = bq2560x_charging_disable(bq, BATT_PRES, !bq->batt_present);
+			if (ret) {
+				pr_err("failed to %s charging, ret = %d\n",
+						bq->batt_present ? "disable" : "enable",
+						ret);
+			}
+			power_supply_changed(&bq->batt_psy);
+			power_supply_changed(bq->usb_psy);
+		}
+	}
+
+}
+
+static void bq2560x_check_batt_full(struct bq2560x *bq)
+{
+	int ret = 0;
+	bool chg_disabled_fc;
+
+	ret = bq2560x_get_prop_batt_full(bq);
+	if (!ret) {
+		chg_disabled_fc = !!(bq->charging_disabled_status & BATT_FC);
+		if (chg_disabled_fc != bq->batt_full) {
+			ret = bq2560x_charging_disable(bq, BATT_FC, bq->batt_full);
+			if (ret) {
+				pr_err("failed to %s charging, ret = %d\n",
+						bq->batt_full ? "disable" : "enable",
+						ret);
+			}
+			power_supply_changed(&bq->batt_psy);
+			power_supply_changed(bq->usb_psy);
+		}
+	}
+}
+
+
+static int calculate_jeita_poll_interval(struct bq2560x* bq)
+{
+	int interval;
+
+	if (bq->batt_hot || bq->batt_cold)
+		interval = 5;
+	else if (bq->batt_warm || bq->batt_cool || bq->batt_cool_xiaomi)
+		interval = 10;
+	else
+		interval = 15;
+	return interval;
+}
+
+#define	FG_LOG_INTERVAL		600
+static void bq2560x_dump_fg_reg(struct bq2560x *bq)
+{
+	union power_supply_propval val = {0,};
+	static int dump_cnt;
+
+	if (++dump_cnt >= (FG_LOG_INTERVAL / calculate_jeita_poll_interval(bq))) {
+		dump_cnt = 0;
+		val.intval = 0;
+		bq->bms_psy->set_property(bq->bms_psy,
+				POWER_SUPPLY_PROP_UPDATE_NOW, &val);
+	}
+}
+
+static enum alarmtimer_restart bq2560x_jeita_alarm_cb(struct alarm *alarm,
+							ktime_t now)
+{
+	struct bq2560x *bq = container_of(alarm,
+							struct bq2560x, jeita_alarm);
+	unsigned long ns;
+
+	bq2560x_stay_awake(&bq->bq2560x_ws, WAKEUP_SRC_JEITA);
+	schedule_delayed_work(&bq->charge_jeita_work, HZ/2);
+
+	ns = calculate_jeita_poll_interval(bq) * 1000000000LL;
+	alarm_forward_now(alarm, ns_to_ktime(ns));
+	return ALARMTIMER_RESTART;
+}
+
+static void bq2560x_dump_status(struct bq2560x* bq);
+static void bq2560x_charge_jeita_workfunc(struct work_struct *work)
+{
+	struct bq2560x *bq = container_of(work,
+							struct bq2560x, charge_jeita_work.work);
+
+	bq2560x_reset_watchdog_timer(bq);
+
+	bq2560x_check_batt_pres(bq);
+	bq2560x_check_batt_full(bq);
+	bq2560x_dump_fg_reg(bq);
+
+	bq2560x_check_jeita(bq);
+	bq2560x_dump_status(bq);
+	bq2560x_relax(&bq->bq2560x_ws, WAKEUP_SRC_JEITA);
+}
+
+
+static void bq2560x_discharge_jeita_workfunc(struct work_struct *work)
+{
+	struct bq2560x *bq = container_of(work,
+							struct bq2560x, discharge_jeita_work.work);
+
+	bq2560x_check_batt_pres(bq);
+	bq2560x_check_batt_full(bq);
+	bq2560x_dump_fg_reg(bq);
+
+	bq2560x_check_jeita(bq);
+
+	schedule_delayed_work(&bq->discharge_jeita_work,
+							calculate_jeita_poll_interval(bq) * HZ);
+}
+
+static const unsigned char* charge_stat_str[] = {
+	"Not Charging",
+	"Precharging",
+	"Fast Charging",
+	"Charge Done",
+};
+
+static void bq2560x_dump_status(struct bq2560x* bq)
+{
+	u8 status;
+	u8 addr;
+	int ret;
+	u8 val;
+	union power_supply_propval batt_prop = {0,};
+
+	ret = bq2560x_get_batt_property(bq,
+					POWER_SUPPLY_PROP_CURRENT_NOW, &batt_prop);
+
+	if (!ret)
+			pr_debug("FG current:%d\n", batt_prop.intval);
+
+	for (addr = 0x0; addr <= 0x0B; addr++) {
+		ret = bq2560x_read_byte(bq, &val, addr);
+		if (!ret)
+				pr_debug("bq Reg[%02X] = 0x%02X\n", addr, val);
+		else
+			pr_err("bq Reg red err\n");
+	}
+	if (!bq->power_good)
+		pr_info("Power Poor\n");
+	if (!bq->vbus_good)
+		pr_err("Vbus voltage not good!\n");
+	if (bq->vindpm_triggered)
+		pr_debug("VINDPM triggered\n");
+	if (bq->iindpm_triggered)
+		pr_debug("IINDPM triggered\n");
+	if (bq->acov_triggered)
+		pr_err("ACOV triggered\n");
+
+	if (bq->fault_status & REG09_FAULT_WDT_MASK)
+		pr_err("Watchdog timer expired!\n");
+	if (bq->fault_status & REG09_FAULT_BOOST_MASK)
+		pr_err("Boost fault occurred!\n");
+
+	status = (bq->fault_status & REG09_FAULT_CHRG_MASK) >> REG09_FAULT_CHRG_SHIFT;
+	if (status == REG09_FAULT_CHRG_INPUT)
+		pr_err("input fault!\n");
+	else if (status == REG09_FAULT_CHRG_THERMAL)
+		pr_err("charge thermal shutdown fault!\n");
+	else if (status == REG09_FAULT_CHRG_TIMER)
+		pr_err("charge timer expired fault!\n");
+
+	if (bq->fault_status & REG09_FAULT_BAT_MASK)
+		pr_err("battery ovp fault!\n");
+
+	if (!bq->software_jeita_supported) {
+		status = (bq->fault_status & REG09_FAULT_NTC_MASK) >> REG09_FAULT_NTC_SHIFT;
+
+		if (status == REG09_FAULT_NTC_WARM)
+			pr_debug("JEITA ACTIVE: WARM\n");
+		else if (status == REG09_FAULT_NTC_COOL)
+			pr_debug("JEITA ACTIVE: COOL\n");
+		else if (status == REG09_FAULT_NTC_COLD)
+			pr_debug("JEITA ACTIVE: COLD\n");
+		else if (status == REG09_FAULT_NTC_HOT)
+			pr_debug("JEITA ACTIVE: HOT!\n");
+	} else if (bq->jeita_active) {
+		if (bq->batt_hot)
+			pr_debug("JEITA ACTIVE: HOT\n");
+		else if (bq->batt_warm)
+			pr_debug("JEITA ACTIVE: WARM\n");
+		else if (bq->batt_cool)
+			pr_debug("JEITA ACTIVE: COOL\n");
+		else if (bq->batt_cool_xiaomi)
+			pr_debug("JEITA ACTIVE: COOL_XIAOMI\n");
+		else if (bq->batt_cold)
+			pr_debug("JEITA ACTIVE: COLD\n");
+	}
+
+	pr_debug("%s\n",charge_stat_str[bq->charge_state]);
+}
+
+
+static void bq2560x_update_status(struct bq2560x *bq)
+{
+	u8 status;
+	int ret;
+
+	ret = bq2560x_read_byte(bq, &status, BQ2560X_REG_0A);
+	if (ret) {
+		pr_err("failed to read reg0a\n");
+		return;
+	}
+
+	mutex_lock(&bq->data_lock);
+	bq->vbus_good = !!(status & REG0A_VBUS_GD_MASK);
+	bq->vindpm_triggered = !!(status & REG0A_VINDPM_STAT_MASK);
+	bq->iindpm_triggered = !!(status & REG0A_IINDPM_STAT_MASK);
+	bq->topoff_active = !!(status & REG0A_TOPOFF_ACTIVE_MASK);
+	bq->acov_triggered = !!(status & REG0A_ACOV_STAT_MASK);
+	mutex_unlock(&bq->data_lock);
+
+	ret = bq2560x_read_byte(bq, &status, BQ2560X_REG_09);
+	ret = bq2560x_read_byte(bq, &status, BQ2560X_REG_09);
+	if (ret)
+		return;
+
+	mutex_lock(&bq->data_lock);
+	bq->fault_status = status;
+	mutex_unlock(&bq->data_lock);
+
+}
+
+
+static irqreturn_t bq2560x_charger_interrupt(int irq, void *dev_id)
+{
+	struct bq2560x *bq = dev_id;
+
+	u8 status;
+	int ret;
+
+	mutex_lock(&bq->irq_complete);
+	bq->irq_waiting = true;
+	if (!bq->resume_completed) {
+		dev_dbg(bq->dev, "IRQ triggered before device-resume\n");
+		if (!bq->irq_disabled) {
+			disable_irq_nosync(irq);
+			bq->irq_disabled = true;
+		}
+		mutex_unlock(&bq->irq_complete);
+		return IRQ_HANDLED;
+	}
+	bq->irq_waiting = false;
+	ret = bq2560x_read_byte(bq, &status, BQ2560X_REG_08);
+	if (ret) {
+		mutex_unlock(&bq->irq_complete);
+		return IRQ_HANDLED;
+	}
+
+	mutex_lock(&bq->data_lock);
+	bq->power_good = !!(status & REG08_PG_STAT_MASK);
+	mutex_unlock(&bq->data_lock);
+
+	if(!bq->power_good) {
+	    if(bq->usb_present) {
+			bq->usb_present = false;
+			power_supply_set_present(bq->usb_psy, bq->usb_present);
+		}
+
+		if (bq->software_jeita_supported) {
+			alarm_try_to_cancel(&bq->jeita_alarm);
+		}
+
+		bq2560x_disable_watchdog_timer(bq);
+
+		schedule_delayed_work(&bq->discharge_jeita_work,
+							calculate_jeita_poll_interval(bq) * HZ);
+
+		pr_err("usb removed, set usb present = %d\n", bq->usb_present);
+	} else if (bq->power_good && !bq->usb_present) {
+		bq->usb_present = true;
+		msleep(10);
+		power_supply_set_present(bq->usb_psy, bq->usb_present);
+
+		cancel_delayed_work(&bq->discharge_jeita_work);
+
+		if (bq->software_jeita_supported) { 
+			ret = alarm_start_relative(&bq->jeita_alarm,
+						ns_to_ktime(calculate_jeita_poll_interval(bq) * 1000000000LL));
+			if (ret)
+				pr_err("start alarm for JEITA detection failed, ret=%d\n",
+							ret);
+		}
+
+		bq2560x_set_watchdog_timer(bq, 80);
+
+		pr_err("usb plugged in, set usb present = %d\n", bq->usb_present);
+	}
+
+	bq2560x_update_status(bq);
+
+	mutex_unlock(&bq->irq_complete);
+
+	power_supply_changed(&bq->batt_psy);
+
+	return IRQ_HANDLED;
+}
+
+
+static void determine_initial_status(struct bq2560x *bq)
+{
+	int ret;
+	u8 status = 0;
+	ret = bq2560x_get_hiz_mode(bq, &status);
+	if (!ret)
+		bq->in_hiz = !!status;
+
+	bq2560x_charger_interrupt(bq->client->irq, bq);
+}
+
+
+static ssize_t bq2560x_show_registers(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct bq2560x *bq = dev_get_drvdata(dev);
+	u8 addr;
+	u8 val;
+	u8 tmpbuf[200];
+	int len;
+	int idx = 0;
+	int ret ;
+
+	idx = snprintf(buf, PAGE_SIZE, "%s:\n", "bq2560x Reg");
+	for (addr = 0x0; addr <= 0x0B; addr++) {
+		ret = bq2560x_read_byte(bq, &val, addr);
+		if (ret == 0) {
+			len = snprintf(tmpbuf, PAGE_SIZE - idx,"Reg[0x%.2x] = 0x%.2x\n", addr, val);
+			memcpy(&buf[idx], tmpbuf, len);
+			idx += len;
+		}
+	}
+
+	return idx;
+}
+
+static ssize_t bq2560x_store_registers(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct bq2560x *bq = dev_get_drvdata(dev);
+	int ret;
+	unsigned int reg;
+	unsigned int val;
+
+	ret = sscanf(buf, "%x %x", &reg, &val);
+	if (ret == 2 && reg < 0x0B) {
+		bq2560x_write_byte(bq, (unsigned char)reg, (unsigned char)val);
+	}
+
+	return count;
+}
+
+static ssize_t bq2560x_battery_test_status_show(struct device *dev,
+					struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", BatteryTestStatus_enable);
+}
+static ssize_t bq2560x_battery_test_status_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int input;
+
+	if (sscanf(buf, "%u", &input) != 1)
+		retval = -EINVAL;
+	else
+	       BatteryTestStatus_enable = input;
+
+	pr_err("BatteryTestStatus_enable = %d\n", BatteryTestStatus_enable);
+
+	return retval;
+}
+
+#ifdef THERMAL_CONFIG_FB
+static ssize_t bq2560x_thermal_call_status_show(struct device *dev,
+					struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", IsInCall);
+}
+static ssize_t bq2560x_thermal_call_status_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int input;
+
+	if (sscanf(buf, "%u", &input) != 1)
+		retval = -EINVAL;
+	else
+	       IsInCall = input;
+
+	pr_err("IsInCall = %d\n", IsInCall);
+
+	return retval;
+}
+#endif
+
+static ssize_t bq2560x_show_hiz(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct bq2560x *bq = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", bq->in_hiz);
+}
+
+static ssize_t bq2560x_store_hiz(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct bq2560x *bq = dev_get_drvdata(dev);
+	int ret;
+	unsigned int val;
+
+	ret = sscanf(buf, "%d", &val);
+	if (ret == 1) {
+		if (val)
+			ret = bq2560x_enter_hiz_mode(bq);
+		else
+			ret = bq2560x_exit_hiz_mode(bq);
+	}
+	if (!ret)
+		bq->in_hiz = !!val;
+
+	return count;
+}
+
+static ssize_t bq2560x_show_dis_safety(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct bq2560x *bq = dev_get_drvdata(dev);
+	return sprintf(buf, "%d\n", bq->dis_safety);
+}
+
+static ssize_t bq2560x_store_dis_safety(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct bq2560x *bq = dev_get_drvdata(dev);
+	int ret;
+	unsigned int val;
+
+	ret = sscanf(buf, "%d", &val);
+	if (ret == 1) {
+		if (val)
+			ret = bq2560x_disable_safety_timer(bq);
+		else
+			ret = bq2560x_enable_safety_timer(bq);
+	}
+	if (!ret)
+		bq->dis_safety = !!val;
+
+	return count;
+}
+
+static DEVICE_ATTR(registers, S_IRUGO | S_IWUSR, bq2560x_show_registers, bq2560x_store_registers);
+static DEVICE_ATTR(BatteryTestStatus, S_IRUGO | S_IWUSR, bq2560x_battery_test_status_show, bq2560x_battery_test_status_store);
+#ifdef THERMAL_CONFIG_FB
+static DEVICE_ATTR(thermalcall, S_IRUGO | S_IWUSR, bq2560x_thermal_call_status_show, bq2560x_thermal_call_status_store);
+#endif
+static DEVICE_ATTR(hiz, S_IRUGO | S_IWUSR, bq2560x_show_hiz, bq2560x_store_hiz);
+static DEVICE_ATTR(dissafety, S_IRUGO | S_IWUSR, bq2560x_show_dis_safety, bq2560x_store_dis_safety);
+
+static struct attribute *bq2560x_attributes[] = {
+	&dev_attr_registers.attr,
+	&dev_attr_BatteryTestStatus.attr,
+	#ifdef THERMAL_CONFIG_FB
+	&dev_attr_thermalcall.attr,
+	#endif
+	&dev_attr_hiz.attr,
+	&dev_attr_dissafety.attr,
+	NULL,
+};
+
+static const struct attribute_group bq2560x_attr_group = {
+	.attrs = bq2560x_attributes,
+};
+
+
+static int show_registers(struct seq_file *m, void *data)
+{
+	struct bq2560x *bq = m->private;
+	u8 addr;
+	int ret;
+	u8 val;
+
+	for (addr = 0x0; addr <= 0x0B; addr++) {
+		ret = bq2560x_read_byte(bq, &val, addr);
+		if (!ret)
+			seq_printf(m, "Reg[%02X] = 0x%02X\n", addr, val);
+	}
+	return 0;
+}
+
+
+static int reg_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct bq2560x *bq = inode->i_private;
+
+	return single_open(file, show_registers, bq);
+}
+
+
+static const struct file_operations reg_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= reg_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void create_debugfs_entry(struct bq2560x *bq)
+{
+	bq->debug_root = debugfs_create_dir("bq2560x", NULL);
+	if (!bq->debug_root)
+		pr_err("Failed to create debug dir\n");
+
+	if (bq->debug_root) {
+
+		debugfs_create_file("registers", S_IFREG | S_IRUGO,
+						bq->debug_root, bq, &reg_debugfs_ops);
+
+		debugfs_create_x32("charging_disable_status", S_IFREG | S_IRUGO,
+						bq->debug_root, &(bq->charging_disabled_status));
+
+		debugfs_create_x32("fault_status", S_IFREG | S_IRUGO,
+						bq->debug_root, &(bq->fault_status));
+
+		debugfs_create_x32("vbus_type", S_IFREG | S_IRUGO,
+						bq->debug_root, &(bq->vbus_type));
+
+		debugfs_create_x32("charge_state", S_IFREG | S_IRUGO,
+						bq->debug_root, &(bq->charge_state));
+
+		debugfs_create_x32("skip_reads",
+					  S_IFREG | S_IWUSR | S_IRUGO,
+					  bq->debug_root,
+					  &(bq->skip_reads));
+		debugfs_create_x32("skip_writes",
+					  S_IFREG | S_IWUSR | S_IRUGO,
+					  bq->debug_root,
+					  &(bq->skip_writes));
+	}
+}
+
+#ifdef THERMAL_CONFIG_FB
+static void thermal_fb_notifier_resume_work(struct work_struct *work)
+{
+	struct bq2560x *bq = container_of(work, struct bq2560x, fb_notify_work);
+	LctThermal = 1;
+	if((bq->backlight_off) && (IsInCall == 0))
+		bq2560x_system_temp_level_set(bq,0);
+	else
+		bq2560x_system_temp_level_set(bq,bq->therm_lvl_reserved);
+	LctThermal = 0;
+}
+
+static int thermal_notifier_callback(struct notifier_block *noti, unsigned long event, void *data)
+{
+	struct fb_event *ev_data = data;
+	struct bq2560x *bq = container_of(noti, struct bq2560x, notifier);
+	int *blank;
+
+	if (ev_data && ev_data->data && bq) {
+		blank = ev_data->data;
+
+		if (event == FB_EARLY_EVENT_BLANK && *blank == FB_BLANK_UNBLANK) {
+
+			bq->backlight_off = false;
+			schedule_work(&bq->fb_notify_work);
+
+		} else if (event == FB_EVENT_BLANK && *blank == FB_BLANK_POWERDOWN) {
+			bq->backlight_off = true;
+			schedule_work(&bq->fb_notify_work);
+
+		}
+	}
+
+	return 0;
+}
+
+static int bq_register_powermanger(struct bq2560x *bq)
+{
+#if defined(CONFIG_FB)
+	bq->notifier.notifier_call = thermal_notifier_callback;
+	fb_register_client(&bq->notifier);
+#endif
+
+	return 0;
+}
+
+static int bq_unregister_powermanger(struct bq2560x *bq)
+{
+#if defined(CONFIG_FB)
+	fb_unregister_client(&bq->notifier);
+#endif
+
+	return 0;
+}
+#endif
+
+static int bq2560x_charger_probe(struct i2c_client *client,
+					const struct i2c_device_id *id)
+{
+	struct bq2560x *bq;
+	struct power_supply *usb_psy;
+	struct power_supply *bms_psy;
+
+	int ret;
+
+	usb_psy = power_supply_get_by_name("usb");
+	if (!usb_psy) {
+		dev_dbg(&client->dev, "USB supply not found, defer probe\n");
+		return -EPROBE_DEFER;
+	}
+
+	bms_psy = power_supply_get_by_name("bms");
+	if (!bms_psy) {
+		dev_dbg(&client->dev, "bms supply not found, defer probe\n");
+		return -EPROBE_DEFER;
+	}
+
+	bq = devm_kzalloc(&client->dev, sizeof(struct bq2560x), GFP_KERNEL);
+	if (!bq) {
+		pr_err("Out of memory\n");
+		return -ENOMEM;
+	}
+
+	bq->dev = &client->dev;
+	bq->usb_psy = usb_psy;
+	bq->bms_psy = bms_psy;
+
+	bq->client = client;
+	i2c_set_clientdata(client, bq);
+
+	mutex_init(&bq->i2c_rw_lock);
+	mutex_init(&bq->data_lock);
+	mutex_init(&bq->profile_change_lock);
+	mutex_init(&bq->charging_disable_lock);
+	mutex_init(&bq->irq_complete);
+
+	bq->resume_completed = true;
+	bq->irq_waiting = false;
+
+	ret = bq2560x_detect_device(bq);
+	if(ret) {
+		pr_err("No bq2560x device found!\n");
+		return -ENODEV;
+	}
+
+	bq2560x_init_jeita(bq);
+
+	if (client->dev.of_node)
+		bq->platform_data = bq2560x_parse_dt(&client->dev, bq);
+	else
+		bq->platform_data = client->dev.platform_data;
+
+	if (!bq->platform_data) {
+		pr_err("No platform data provided.\n");
+		return -EINVAL;
+	}
+
+	if (gpio_is_valid(bq->gpio_ce)) {
+		ret = devm_gpio_request(&client->dev, bq->gpio_ce, "bq2560x_ce");
+		if (ret) {
+			pr_err("Failed to request chip enable gpio %d:, err: %d\n", bq->gpio_ce, ret);
+			return ret;
+		}
+		gpio_direction_output(bq->gpio_ce, 0);
+	}
+
+	ret = bq2560x_init_device(bq);
+	if (ret) {
+		pr_err("Failed to init device\n");
+		return ret;
+	}
+
+
+	ret = bq2560x_psy_register(bq);
+	if (ret)
+		return ret;
+	ret = bq2560x_regulator_init(bq);
+	if (ret) {
+		pr_err("Couldn't initialize bq2560x regulator ret=%d\n", ret);
+		return ret;
+	}
+
+	INIT_DELAYED_WORK(&bq->charge_jeita_work, bq2560x_charge_jeita_workfunc);
+	INIT_DELAYED_WORK(&bq->discharge_jeita_work, bq2560x_discharge_jeita_workfunc);
+
+	alarm_init(&bq->jeita_alarm, ALARM_BOOTTIME, bq2560x_jeita_alarm_cb);
+
+	if (client->irq) {
+		ret = devm_request_threaded_irq(&client->dev, client->irq, NULL,
+				bq2560x_charger_interrupt,
+				IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+				"bq2560x charger irq", bq);
+		if (ret < 0) {
+			pr_err("request irq for irq=%d failed, ret =%d\n", client->irq, ret);
+			goto err_1;
+		}
+		enable_irq_wake(client->irq);
+	}
+
+	bq2560x_wakeup_src_init(bq);
+
+	device_init_wakeup(bq->dev, 1);
+	create_debugfs_entry(bq);
+
+	ret = sysfs_create_group(&bq->dev->kobj, &bq2560x_attr_group);
+	if (ret) {
+		dev_err(bq->dev, "failed to register sysfs. err: %d\n", ret);
+	}
+
+	determine_initial_status(bq);
+
+	#ifdef THERMAL_CONFIG_FB
+	bq->therm_lvl_reserved = 0;
+	bq->backlight_off = false;
+	INIT_WORK(&bq->fb_notify_work, thermal_fb_notifier_resume_work);
+	bq_register_powermanger(bq);
+	#endif
+
+	pr_err("bq2560x probe successfully, Part Num:%d, Revision:%d\n!",
+				bq->part_no, bq->revision);
+
+	return 0;
+
+err_1:
+	bq2560x_psy_unregister(bq);
+
+	return ret;
+}
+
+static inline bool is_device_suspended(struct bq2560x *bq)
+{
+	return !bq->resume_completed;
+}
+
+static int bq2560x_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bq2560x *bq = i2c_get_clientdata(client);
+
+	mutex_lock(&bq->irq_complete);
+	bq->resume_completed = false;
+	mutex_unlock(&bq->irq_complete);
+
+
+	return 0;
+}
+
+static int bq2560x_suspend_noirq(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bq2560x *bq = i2c_get_clientdata(client);
+
+	if (bq->irq_waiting) {
+		pr_err_ratelimited("Aborting suspend, an interrupt was detected while suspending\n");
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static int bq2560x_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bq2560x *bq = i2c_get_clientdata(client);
+
+
+	mutex_lock(&bq->irq_complete);
+	bq->resume_completed = true;
+	if (bq->irq_waiting) {
+		bq->irq_disabled = false;
+		enable_irq(client->irq);
+		mutex_unlock(&bq->irq_complete);
+		bq2560x_charger_interrupt(client->irq, bq);
+	} else {
+		mutex_unlock(&bq->irq_complete);
+	}
+
+	power_supply_changed(&bq->batt_psy);
+
+
+	return 0;
+}
+static int bq2560x_charger_remove(struct i2c_client *client)
+{
+	struct bq2560x *bq = i2c_get_clientdata(client);
+
+	#ifdef THERMAL_CONFIG_FB
+	bq_unregister_powermanger(bq);
+	#endif
+
+	alarm_try_to_cancel(&bq->jeita_alarm);
+
+	cancel_delayed_work_sync(&bq->charge_jeita_work);
+	cancel_delayed_work_sync(&bq->discharge_jeita_work);
+
+	regulator_unregister(bq->otg_vreg.rdev);
+
+	bq2560x_psy_unregister(bq);
+
+	mutex_destroy(&bq->charging_disable_lock);
+	mutex_destroy(&bq->profile_change_lock);
+	mutex_destroy(&bq->data_lock);
+	mutex_destroy(&bq->i2c_rw_lock);
+	mutex_destroy(&bq->irq_complete);
+
+	debugfs_remove_recursive(bq->debug_root);
+	sysfs_remove_group(&bq->dev->kobj, &bq2560x_attr_group);
+
+
+	return 0;
+}
+
+
+static void bq2560x_charger_shutdown(struct i2c_client *client)
+{
+
+}
+
+static struct of_device_id bq2560x_charger_match_table[] = {
+	{.compatible = "ti,bq25600-charger",},
+	{.compatible = "ti,bq25601-charger",},
+	{},
+};
+MODULE_DEVICE_TABLE(of,bq2560x_charger_match_table);
+
+static const struct i2c_device_id bq2560x_charger_id[] = {
+	{ "bq25600-charger", BQ25600 },
+	{ "bq25601-charger", BQ25601 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, bq2560x_charger_id);
+
+static const struct dev_pm_ops bq2560x_pm_ops = {
+	.resume		= bq2560x_resume,
+	.suspend_noirq = bq2560x_suspend_noirq,
+	.suspend	= bq2560x_suspend,
+};
+static struct i2c_driver bq2560x_charger_driver = {
+	.driver 	= {
+		.name 	= "bq2560x-charger",
+		.owner 	= THIS_MODULE,
+		.of_match_table = bq2560x_charger_match_table,
+		.pm		= &bq2560x_pm_ops,
+	},
+	.id_table	= bq2560x_charger_id,
+
+	.probe		= bq2560x_charger_probe,
+	.remove		= bq2560x_charger_remove,
+	.shutdown	= bq2560x_charger_shutdown,
+
+};
+
+module_i2c_driver(bq2560x_charger_driver);
+
+MODULE_DESCRIPTION("TI BQ2560x Charger Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Texas Instruments");
diff --git a/drivers/power/supply/qcom/bq2560x_reg.h b/drivers/power/supply/qcom/bq2560x_reg.h
new file mode 100644
index 000000000000..7dcd30a092e0
--- /dev/null
+++ b/drivers/power/supply/qcom/bq2560x_reg.h
@@ -0,0 +1,307 @@
+
+#ifndef __BQ2560X_HEADER__
+#define __BQ2560X_HEADER__
+
+/* Register 00h */
+#define BQ2560X_REG_00      		0x00
+#define REG00_ENHIZ_MASK		    0x80
+#define REG00_ENHIZ_SHIFT		    7
+#define	REG00_HIZ_ENABLE			1
+#define	REG00_HIZ_DISABLE			0
+
+#define	REG00_STAT_CTRL_MASK		0x60
+#define REG00_STAT_CTRL_SHIFT		5
+#define	REG00_STAT_CTRL_STAT		0
+#define	REG00_STAT_CTRL_ICHG		1
+#define	REG00_STAT_CTRL_IINDPM		2
+#define	REG00_STAT_CTRL_DISABLE		3
+
+#define REG00_IINLIM_MASK		    0x1F
+#define REG00_IINLIM_SHIFT			0
+#define	REG00_IINLIM_LSB			100
+#define	REG00_IINLIM_BASE			100
+
+/* Register 01h */
+#define BQ2560X_REG_01		    	0x01
+#define REG01_PFM_DIS_MASK	      	0x80
+#define	REG01_PFM_DIS_SHIFT			7
+#define	REG01_PFM_ENABLE			0
+#define	REG01_PFM_DISABLE			1
+
+#define REG01_WDT_RESET_MASK		0x40
+#define REG01_WDT_RESET_SHIFT		6
+#define REG01_WDT_RESET				1
+
+#define	REG01_OTG_CONFIG_MASK		0x20
+#define	REG01_OTG_CONFIG_SHIFT		5
+#define	REG01_OTG_ENABLE			1
+#define	REG01_OTG_DISABLE			0
+
+#define REG01_CHG_CONFIG_MASK     	0x10
+#define REG01_CHG_CONFIG_SHIFT    	4
+#define REG01_CHG_DISABLE        	0
+#define REG01_CHG_ENABLE         	1
+
+#define REG01_SYS_MINV_MASK       	0x0E
+#define REG01_SYS_MINV_SHIFT      	1
+
+#define	REG01_MIN_VBAT_SEL_MASK		0x01
+#define	REG01_MIN_VBAT_SEL_SHIFT	0
+#define	REG01_MIN_VBAT_2P8V			0
+#define	REG01_MIN_VBAT_2P5V			1
+
+
+/* Register 0x02*/
+#define BQ2560X_REG_02              0x02
+#define	REG02_BOOST_LIM_MASK		0x80
+#define	REG02_BOOST_LIM_SHIFT		7
+#define	REG02_BOOST_LIM_0P5A		0
+#define	REG02_BOOST_LIM_1P2A		1
+
+#define	REG02_Q1_FULLON_MASK		0x40
+#define	REG02_Q1_FULLON_SHIFT		6
+#define	REG02_Q1_FULLON_ENABLE		1
+#define	REG02_Q1_FULLON_DISABLE		0
+
+#define REG02_ICHG_MASK           	0x3F
+#define REG02_ICHG_SHIFT          	0
+#define REG02_ICHG_BASE           	0
+#define REG02_ICHG_LSB            	60
+
+/* Register 0x03*/
+#define BQ2560X_REG_03              	0x03
+#define REG03_IPRECHG_MASK        	0xF0
+#define REG03_IPRECHG_SHIFT       	4
+#define REG03_IPRECHG_BASE        	60
+#define REG03_IPRECHG_LSB         	60
+
+#define REG03_ITERM_MASK          	0x0F
+#define REG03_ITERM_SHIFT         	0
+#define REG03_ITERM_BASE          	60
+#define REG03_ITERM_LSB           	60
+
+
+/* Register 0x04*/
+#define BQ2560X_REG_04              0x04
+#define REG04_VREG_MASK           	0xF8
+#define REG04_VREG_SHIFT          	3
+#define REG04_VREG_BASE           	3856
+#define REG04_VREG_LSB            	32
+
+#define	REG04_TOPOFF_TIMER_MASK		0x06
+#define	REG04_TOPOFF_TIMER_SHIFT	1
+#define	REG04_TOPOFF_TIMER_DISABLE	0
+#define	REG04_TOPOFF_TIMER_15M		1
+#define	REG04_TOPOFF_TIMER_30M		2
+#define	REG04_TOPOFF_TIMER_45M		3
+
+
+#define REG04_VRECHG_MASK         	0x01
+#define REG04_VRECHG_SHIFT        	0
+#define REG04_VRECHG_100MV        	0
+#define REG04_VRECHG_200MV        	1
+
+/* Register 0x05*/
+#define BQ2560X_REG_05             	0x05
+#define REG05_EN_TERM_MASK        	0x80
+#define REG05_EN_TERM_SHIFT       	7
+#define REG05_TERM_ENABLE         	1
+#define REG05_TERM_DISABLE        	0
+
+#define REG05_WDT_MASK            	0x30
+#define REG05_WDT_SHIFT           	4
+#define REG05_WDT_DISABLE         	0
+#define REG05_WDT_40S             	1
+#define REG05_WDT_80S             	2
+#define REG05_WDT_160S            	3
+#define REG05_WDT_BASE            	0
+#define REG05_WDT_LSB             	40
+
+#define REG05_EN_TIMER_MASK       	0x08
+#define REG05_EN_TIMER_SHIFT      	3
+#define REG05_CHG_TIMER_ENABLE    	1
+#define REG05_CHG_TIMER_DISABLE   	0
+
+#define REG05_CHG_TIMER_MASK      	0x04
+#define REG05_CHG_TIMER_SHIFT     	2
+#define REG05_CHG_TIMER_5HOURS    	0
+#define REG05_CHG_TIMER_10HOURS   	1
+
+#define	REG05_TREG_MASK				0x02
+#define	REG05_TREG_SHIFT			1
+#define	REG05_TREG_90C				0
+#define	REG05_TREG_110C				1
+
+#define REG05_JEITA_ISET_MASK     	0x01
+#define REG05_JEITA_ISET_SHIFT    	0
+#define REG05_JEITA_ISET_50PCT    	0
+#define REG05_JEITA_ISET_20PCT    	1
+
+
+/* Register 0x06*/
+#define BQ2560X_REG_06              0x06
+#define	REG06_OVP_MASK				0xC0
+#define	REG06_OVP_SHIFT				0x6
+#define	REG06_OVP_5P5V				0
+#define	REG06_OVP_6P2V				1
+#define	REG06_OVP_10P5V				2
+#define	REG06_OVP_14P3V				3
+
+#define	REG06_BOOSTV_MASK			0x30
+#define	REG06_BOOSTV_SHIFT			4
+#define	REG06_BOOSTV_4P85V			0
+#define	REG06_BOOSTV_5V				1
+#define	REG06_BOOSTV_5P15V			2
+#define	REG06_BOOSTV_5P3V			3
+
+#define	REG06_VINDPM_MASK			0x0F
+#define	REG06_VINDPM_SHIFT			0
+#define	REG06_VINDPM_BASE			3900
+#define	REG06_VINDPM_LSB			100
+
+/* Register 0x07*/
+#define BQ2560X_REG_07              0x07
+#define REG07_FORCE_DPDM_MASK     	0x80
+#define REG07_FORCE_DPDM_SHIFT    	7
+#define REG07_FORCE_DPDM          	1
+
+#define REG07_TMR2X_EN_MASK       	0x40
+#define REG07_TMR2X_EN_SHIFT      	6
+#define REG07_TMR2X_ENABLE        	1
+#define REG07_TMR2X_DISABLE       	0
+
+#define REG07_BATFET_DIS_MASK     	0x20
+#define REG07_BATFET_DIS_SHIFT    	5
+#define REG07_BATFET_OFF          	1
+#define REG07_BATFET_ON          	0
+
+#define REG07_JEITA_VSET_MASK     	0x10
+#define REG07_JEITA_VSET_SHIFT    	4
+#define REG07_JEITA_VSET_4100     	0
+#define REG07_JEITA_VSET_VREG     	1
+
+#define	REG07_BATFET_DLY_MASK		0x08
+#define	REG07_BATFET_DLY_SHIFT		3
+#define	REG07_BATFET_DLY_0S			0
+#define	REG07_BATFET_DLY_10S		1
+
+#define	REG07_BATFET_RST_EN_MASK	0x04
+#define	REG07_BATFET_RST_EN_SHIFT	2
+#define	REG07_BATFET_RST_DISABLE	0
+#define	REG07_BATFET_RST_ENABLE		1
+
+#define	REG07_VDPM_BAT_TRACK_MASK	0x03
+#define	REG07_VDPM_BAT_TRACK_SHIFT 	0
+#define	REG07_VDPM_BAT_TRACK_DISABLE	0
+#define	REG07_VDPM_BAT_TRACK_200MV	1
+#define	REG07_VDPM_BAT_TRACK_250MV	2
+#define	REG07_VDPM_BAT_TRACK_300MV	3
+
+/* Register 0x08*/
+#define BQ2560X_REG_08              0x08
+#define REG08_VBUS_STAT_MASK      0xE0
+#define REG08_VBUS_STAT_SHIFT     5
+#define REG08_VBUS_TYPE_NONE	  0
+#define REG08_VBUS_TYPE_USB       1
+#define REG08_VBUS_TYPE_ADAPTER   3
+#define REG08_VBUS_TYPE_OTG       7
+
+#define REG08_CHRG_STAT_MASK      0x18
+#define REG08_CHRG_STAT_SHIFT     3
+#define REG08_CHRG_STAT_IDLE      0
+#define REG08_CHRG_STAT_PRECHG    1
+#define REG08_CHRG_STAT_FASTCHG   2
+#define REG08_CHRG_STAT_CHGDONE   3
+
+#define REG08_PG_STAT_MASK        0x04
+#define REG08_PG_STAT_SHIFT       2
+#define REG08_POWER_GOOD          1
+
+#define REG08_THERM_STAT_MASK     0x02
+#define REG08_THERM_STAT_SHIFT    1
+
+#define REG08_VSYS_STAT_MASK      0x01
+#define REG08_VSYS_STAT_SHIFT     0
+#define REG08_IN_VSYS_STAT        1
+
+
+/* Register 0x09*/
+#define BQ2560X_REG_09              0x09
+#define REG09_FAULT_WDT_MASK      0x80
+#define REG09_FAULT_WDT_SHIFT     7
+#define REG09_FAULT_WDT           1
+
+#define REG09_FAULT_BOOST_MASK    0x40
+#define REG09_FAULT_BOOST_SHIFT   6
+
+#define REG09_FAULT_CHRG_MASK     0x30
+#define REG09_FAULT_CHRG_SHIFT    4
+#define REG09_FAULT_CHRG_NORMAL   0
+#define REG09_FAULT_CHRG_INPUT    1
+#define REG09_FAULT_CHRG_THERMAL  2
+#define REG09_FAULT_CHRG_TIMER    3
+
+#define REG09_FAULT_BAT_MASK      0x08
+#define REG09_FAULT_BAT_SHIFT     3
+#define	REG09_FAULT_BAT_OVP		1
+
+#define REG09_FAULT_NTC_MASK      0x07
+#define REG09_FAULT_NTC_SHIFT     0
+#define	REG09_FAULT_NTC_NORMAL		0
+#define REG09_FAULT_NTC_WARM      2
+#define REG09_FAULT_NTC_COOL      3
+#define REG09_FAULT_NTC_COLD      5
+#define REG09_FAULT_NTC_HOT       6
+
+
+/* Register 0x0A */
+#define BQ2560X_REG_0A              0x0A
+#define	REG0A_VBUS_GD_MASK			0x80
+#define	REG0A_VBUS_GD_SHIFT			7
+#define	REG0A_VBUS_GD				1
+
+#define	REG0A_VINDPM_STAT_MASK		0x40
+#define	REG0A_VINDPM_STAT_SHIFT		6
+#define	REG0A_VINDPM_ACTIVE			1
+
+#define	REG0A_IINDPM_STAT_MASK		0x20
+#define	REG0A_IINDPM_STAT_SHIFT		5
+#define	REG0A_IINDPM_ACTIVE			1
+
+#define	REG0A_TOPOFF_ACTIVE_MASK	0x08
+#define	REG0A_TOPOFF_ACTIVE_SHIFT	3
+#define	REG0A_TOPOFF_ACTIVE			1
+
+#define	REG0A_ACOV_STAT_MASK		0x04
+#define	REG0A_ACOV_STAT_SHIFT		2
+#define	REG0A_ACOV_ACTIVE			1
+
+#define	REG0A_VINDPM_INT_MASK		0x02
+#define	REG0A_VINDPM_INT_SHIFT		1
+#define	REG0A_VINDPM_INT_ENABLE		0
+#define	REG0A_VINDPM_INT_DISABLE	1
+
+#define	REG0A_IINDPM_INT_MASK		0x01
+#define	REG0A_IINDPM_INT_SHIFT		0
+#define	REG0A_IINDPM_INT_ENABLE		0
+#define	REG0A_IINDPM_INT_DISABLE	1
+
+#define	REG0A_INT_MASK_MASK			0x03
+#define	REG0A_INT_MASK_SHIFT		0
+
+
+#define	BQ2560X_REG_0B				0x0B
+#define	REG0B_REG_RESET_MASK		0x80
+#define	REG0B_REG_RESET_SHIFT		7
+#define	REG0B_REG_RESET				1
+
+#define REG0B_PN_MASK             	0x78
+#define REG0B_PN_SHIFT            	3
+
+#define REG0B_DEV_REV_MASK        	0x03
+#define REG0B_DEV_REV_SHIFT       	0
+
+
+#endif
+
+
diff --git a/drivers/power/supply/qcom/bq27426_fg.c b/drivers/power/supply/qcom/bq27426_fg.c
new file mode 100644
index 000000000000..7af6bf0f97f2
--- /dev/null
+++ b/drivers/power/supply/qcom/bq27426_fg.c
@@ -0,0 +1,2213 @@
+/*
+ * bqGauge battery driver
+ *
+ * Copyright (C) 2008 Rodolfo Giometti <giometti@linux.it>
+ * Copyright (C) 2008 Eurotech S.p.A. <info@eurotech.it>
+ * Copyright (C) 2010-2011 Lars-Peter Clausen <lars@metafoo.de>
+ * Copyright (C) 2011 Pali Rohár <pali.rohar@gmail.com>
+ * Copyright (C) 2018 XiaoMi, Inc.
+ *
+ * Based on a previous work by Copyright (C) 2008 Texas Instruments, Inc.
+ *
+ * This package is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * THIS PACKAGE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
+ * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
+ *
+ */
+
+/*
+ * Datasheets:
+ */
+#define pr_fmt(fmt)	"bq27426- %s: " fmt, __func__
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/jiffies.h>
+#include <linux/workqueue.h>
+#include <linux/delay.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+#include <linux/idr.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/acpi.h>
+#include <asm/unaligned.h>
+#include <linux/uaccess.h>
+#include <linux/interrupt.h>
+#include <linux/gpio/consumer.h>
+#include <linux/debugfs.h>
+#include <linux/qpnp/qpnp-adc.h>
+#include <linux/alarmtimer.h>
+#include "bqfs_cmd_type.h"
+
+#include "bq27426_gmfs_scud.h"
+#include "bq27426_gmfs_coslight.h"
+#include "bq27426_gmfs_sunwoda.h"
+#include "bq27426_gmfs_sdi.h"
+
+#if 1
+
+
+#undef pr_info
+#define pr_info pr_err
+#undef dev_dbg
+#define dev_dbg dev_err
+#else
+#undef pr_info
+#define pr_info pr_debug
+#endif
+
+#define	MONITOR_ALARM_CHECK_NS	5000000000
+#define	INVALID_REG_ADDR	0xFF
+#define BQFS_UPDATE_KEY		0x8F91
+
+
+#define	FG_FLAGS_OT					BIT(15)
+#define	FG_FLAGS_UT					BIT(14)
+#define	FG_FLAGS_FC					BIT(9)
+#define	FG_FLAGS_CHG				BIT(8)
+#define	FG_FLAGS_OCVTAKEN			BIT(7)
+#define	FG_FLAGS_ITPOR				BIT(5)
+#define	FG_FLAGS_CFGUPMODE			BIT(4)
+#define	FG_FLAGS_BAT_DET			BIT(3)
+#define	FG_FLAGS_SOC1				BIT(2)
+#define	FG_FLAGS_SOCF				BIT(1)
+#define	FG_FLAGS_DSG				BIT(0)
+
+
+enum bq_fg_reg_idx {
+	BQ_FG_REG_CTRL = 0,
+	BQ_FG_REG_TEMP,		/* Battery Temperature */
+	BQ_FG_REG_VOLT,		/* Battery Voltage */
+	BQ_FG_REG_AI,		/* Average Current */
+	BQ_FG_REG_FLAGS,	/* Flags */
+	BQ_FG_REG_TTE,		/* Time to Empty */
+	BQ_FG_REG_TTF,		/* Time to Full */
+	BQ_FG_REG_FCC,		/* Full Charge Capacity */
+	BQ_FG_REG_RM,		/* Remaining Capacity */
+	BQ_FG_REG_CC,		/* Cycle Count */
+	BQ_FG_REG_SOC,		/* Relative State of Charge */
+	BQ_FG_REG_SOH,		/* State of Health */
+	BQ_FG_REG_DC,		/* Design Capacity */
+
+	NUM_REGS,
+};
+
+enum bq_fg_subcmd {
+	FG_SUBCMD_CTRL_STATUS	= 0x0000,
+	FG_SUBCMD_PART_NUM		= 0x0001,
+	FG_SUBCMD_FW_VER		= 0x0002,
+	FG_SUBCMD_DM_CODE		= 0x0004,
+	FG_SUBCMD_CHEM_ID		= 0x0008,
+	FG_SUBCMD_BAT_INSERT	= 0x000C,
+	FG_SUBCMD_BAT_REMOVE	= 0x000D,
+	FG_SUBCMD_SET_CFGUPDATE	= 0x0013,
+	FG_SUBCMD_SEAL			= 0x0020,
+	FG_SUBCMD_PULSE_SOC_INT	= 0x0023,
+	FG_SUBCMD_CHEM_A		= 0x0030,
+	FG_SUBCMD_CHEM_B		= 0x0031,
+	FG_SUBCMD_CHEM_C		= 0x0032,
+	FG_SUBCMD_SOFT_RESET	= 0x0042,
+};
+
+
+enum {
+	SEAL_STATE_FA,
+	SEAL_STATE_UNSEALED,
+	SEAL_STATE_SEALED,
+};
+
+
+enum bq_fg_device {
+	BQ27X00,
+	BQ27426,
+};
+
+enum {
+	UPDATE_REASON_FG_RESET = 1,
+	UPDATE_REASON_NEW_VERSION,
+	UPDATE_REASON_FORCED,
+};
+
+struct fg_batt_profile {
+	const bqfs_cmd_t * bqfs_image;
+	u32				   array_size;
+	u8				   version;
+};
+
+struct batt_chem_id {
+	u16 id;
+	u16 cmd;
+};
+
+static struct batt_chem_id batt_chem_id_arr[] = {
+	{3230, FG_SUBCMD_CHEM_A},
+	{1202, FG_SUBCMD_CHEM_B},
+	{3142, FG_SUBCMD_CHEM_C},
+};
+
+static const struct fg_batt_profile bqfs_image[] = {
+	{ bqfs_scud, ARRAY_SIZE(bqfs_scud), 0x10 },
+	{ bqfs_coslight, ARRAY_SIZE(bqfs_coslight), 0x10 },
+	{ bqfs_sunwoda, ARRAY_SIZE(bqfs_sunwoda), 0x10 },
+	{ bqfs_sdi, ARRAY_SIZE(bqfs_sdi), 0x10 },
+};
+
+const unsigned char *device2str[] = {
+	"bq27x00",
+	"bq27426",
+};
+
+const unsigned char *update_reason_str[] = {
+	"Reset",
+	"New Version",
+	"Force"
+};
+
+static u8 bq27426_regs[NUM_REGS] = {
+	0x00,
+	0x02,
+	0x04,
+	0x10,
+	0x06,
+	0xFF,
+	0xFF,
+	0x0E,
+	0x0C,
+	0xFF,
+	0x1C,
+	0x20,
+	0xFF,
+};
+
+struct bq_fg_chip;
+
+enum {
+	BATTERY_PROFILE_A,
+	BATTERY_PROFILE_B,
+	BATTERY_PROFILE_MAX,
+};
+
+struct bq_fg_chip {
+	struct device		*dev;
+	struct i2c_client	*client;
+
+
+	struct mutex i2c_rw_lock;
+	struct mutex data_lock;
+	struct mutex update_lock;
+	struct mutex irq_complete;
+
+	bool irq_waiting;
+	bool irq_disabled;
+	bool resume_completed;
+
+	int	 force_update;
+	int	 fw_ver;
+	int	 df_ver;
+
+	u8	chip;
+	u8	regs[NUM_REGS];
+
+	int	 batt_id;
+
+
+	bool batt_present;
+	bool batt_fc;
+	bool batt_ot;
+	bool batt_ut;
+	bool batt_soc1;
+	bool batt_socf;
+	bool batt_dsg;
+	bool allow_chg;
+	bool cfg_update_mode;
+	bool itpor;
+
+	int	seal_state;
+	int batt_tte;
+	int	batt_soc;
+	int batt_fcc;
+	int batt_rm;
+	int	batt_dc;
+	int	batt_volt;
+	int	batt_temp;
+	int	batt_curr;
+
+	int batt_cyclecnt;
+
+
+	struct work_struct update_work;
+
+	unsigned long last_update;
+
+	int	skip_reads;
+	int	skip_writes;
+
+	int fake_soc;
+	int fake_temp;
+
+	struct dentry *debug_root;
+
+	struct power_supply fg_psy;
+
+	struct qpnp_vadc_chip	*vadc_dev;
+	struct regulator		*vdd;
+	u32	connected_rid;
+#if 0
+	u32	profile_rid[BATTERY_PROFILE_MAX];
+	const char			*batt_type_a;
+	const char			*batt_type_b;
+	bool	rsense_10mohm;
+	bool	force_select_profile_b;
+#endif
+};
+
+
+
+static int __fg_read_byte(struct i2c_client *client, u8 reg, u8 *val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_read_byte_data(client, reg);
+	if (ret < 0) {
+		pr_err("i2c read byte fail: can't read from reg 0x%02X\n", reg);
+		return ret;
+	}
+
+	*val = (u8)ret;
+
+	return 0;
+}
+
+static int __fg_write_byte(struct i2c_client *client, u8 reg, u8 val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_write_byte_data(client, reg, val);
+	if (ret < 0) {
+		pr_err("i2c write byte fail: can't write 0x%02X to reg 0x%02X\n",
+				val, reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+
+static int __fg_read_word(struct i2c_client *client, u8 reg, u16 *val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_read_word_data(client, reg);
+	if (ret < 0) {
+		pr_err("i2c read word fail: can't read from reg 0x%02X\n", reg);
+		return ret;
+	}
+
+	*val = (u16)ret;
+
+	return 0;
+}
+
+
+static int __fg_write_word(struct i2c_client *client, u8 reg, u16 val)
+{
+	s32 ret;
+
+	ret = i2c_smbus_write_word_data(client, reg, val);
+	if (ret < 0) {
+		pr_err("i2c write word fail: can't write 0x%02X to reg 0x%02X\n",
+				val, reg);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int __fg_read_block(struct i2c_client *client, u8 reg, u8 *buf, u8 len)
+{
+	int ret;
+	struct i2c_msg msg[2];
+	int i;
+
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].buf = &reg;
+	msg[0].len = 1;
+
+	msg[1].addr = client->addr;
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = buf;
+	msg[1].len = len;
+
+	for (i = 0; i < 3; i++) {
+		ret = i2c_transfer(client->adapter, msg, ARRAY_SIZE(msg));
+		if (ret >= 0)
+			return ret;
+		else
+			msleep(5);
+	}
+	return ret;
+}
+
+static int __fg_write_block(struct i2c_client *client, u8 reg, u8 *buf, u8 len)
+{
+	int ret;
+	struct i2c_msg msg;
+	u8 data[64];
+	int i = 0;
+
+	data[0] = reg;
+	memcpy(&data[1], buf, len);
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.buf = data;
+	msg.len = len + 1;
+
+	for (i = 0; i < 3; i++) {
+		ret = i2c_transfer(client->adapter, &msg, 1);
+		if (ret >= 0)
+			return ret;
+		else
+			msleep(5);
+	}
+	return ret;
+}
+
+
+static int fg_read_byte(struct bq_fg_chip *bq, u8 reg, u8 *val)
+{
+	int ret;
+
+	if (bq->skip_reads) {
+		*val = 0;
+		return 0;
+	}
+
+	mutex_lock(&bq->i2c_rw_lock);
+	ret = __fg_read_byte(bq->client, reg, val);
+	mutex_unlock(&bq->i2c_rw_lock);
+
+	return ret;
+}
+
+static int fg_write_byte(struct bq_fg_chip *bq, u8 reg, u8 val)
+{
+	int ret;
+
+	if (bq->skip_writes)
+		return 0;
+
+	mutex_lock(&bq->i2c_rw_lock);
+	ret = __fg_write_byte(bq->client, reg, val);
+	mutex_unlock(&bq->i2c_rw_lock);
+
+	return ret;
+}
+
+static int fg_read_word(struct bq_fg_chip *bq, u8 reg, u16 *val)
+{
+	int ret;
+
+	if (bq->skip_reads) {
+		*val = 0;
+		return 0;
+	}
+
+	mutex_lock(&bq->i2c_rw_lock);
+	ret = __fg_read_word(bq->client, reg, val);
+	mutex_unlock(&bq->i2c_rw_lock);
+
+	return ret;
+}
+
+static int fg_write_word(struct bq_fg_chip *bq, u8 reg, u16 val)
+{
+	int ret;
+
+	if (bq->skip_writes)
+		return 0;
+
+
+	mutex_lock(&bq->i2c_rw_lock);
+	ret = __fg_write_word(bq->client, reg, val);
+	mutex_unlock(&bq->i2c_rw_lock);
+
+	return ret;
+}
+
+static int fg_read_block(struct bq_fg_chip *bq, u8 reg, u8 *buf, u8 len)
+{
+	int ret;
+
+	if (bq->skip_reads)
+		return 0;
+	mutex_lock(&bq->i2c_rw_lock);
+	ret = __fg_read_block(bq->client, reg, buf, len);
+	mutex_unlock(&bq->i2c_rw_lock);
+
+	return ret;
+
+}
+
+static int fg_write_block(struct bq_fg_chip *bq, u8 reg, u8 *data, u8 len)
+{
+	int ret;
+
+	if (bq->skip_writes)
+		return 0;
+
+	mutex_lock(&bq->i2c_rw_lock);
+	ret = __fg_write_block(bq->client, reg, data, len);
+	mutex_unlock(&bq->i2c_rw_lock);
+
+	return ret;
+}
+
+#define	CTRL_REG					0x00
+
+#define	FG_DFT_UNSEAL_KEY1				0x80008000
+#define	FG_DFT_UNSEAL_KEY2				0x36724614
+
+#define	FG_DFT_UNSEAL_FA_KEY			0xFFFFFFFF
+
+static u8 checksum(u8 *data, u8 len)
+{
+	u8 i;
+	u16 sum = 0;
+
+	for (i = 0; i < len; i++)
+		sum += data[i];
+
+	sum &= 0xFF;
+
+	return (0xFF - sum);
+}
+
+#if 0
+static void fg_print_buf(const char *msg, u8 *buf, u8 len)
+{
+	int i;
+	int idx = 0;
+	int num;
+	u8 strbuf[128];
+
+	pr_err("%s buf: ", msg);
+	for(i = 0; i < len; i++) {
+		num = sprintf(&strbuf[idx], "%02X ", buf[i]);
+		idx += num;
+	}
+	pr_err("%s\n", strbuf);
+}
+#else
+static void fg_print_buf(const char *msg, u8 *buf, u8 len)
+{}
+#endif
+
+
+#define TIMEOUT_INIT_COMPLETED	100
+static int fg_check_init_completed(struct bq_fg_chip *bq)
+{
+	int ret;
+	int i = 0;
+	u16 status;
+
+	ret = fg_write_word(bq, bq->regs[BQ_FG_REG_CTRL], FG_SUBCMD_CTRL_STATUS);
+	if (ret < 0) {
+		pr_err("Failed to write control status cmd, ret = %d\n", ret);
+		return ret;
+	}
+
+	msleep(5);
+
+	while (i++ < TIMEOUT_INIT_COMPLETED) {
+		ret = fg_read_word(bq, bq->regs[BQ_FG_REG_CTRL], &status);
+		if (ret >= 0 && (status & 0x0080))
+			return 0;
+		msleep(100);
+	}
+	pr_err("wait for FG INITCOMP timeout\n");
+	return ret;
+}
+
+static int fg_get_seal_state(struct bq_fg_chip *bq)
+{
+	int ret;
+	u16 status;
+
+	ret = fg_write_word(bq, bq->regs[BQ_FG_REG_CTRL], FG_SUBCMD_CTRL_STATUS);
+	if (ret < 0) {
+		pr_err("Failed to write control status cmd, ret = %d\n", ret);
+		return ret;
+	}
+
+	msleep(5);
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_CTRL], &status);
+	if (ret < 0) {
+		pr_err("Failed to read control status, ret = %d\n", ret);
+		return ret;
+	}
+	pr_err("control_status = 0x%04X\n", status);
+	if (status & 0x2000)
+		bq->seal_state = SEAL_STATE_SEALED;
+	else
+		bq->seal_state = SEAL_STATE_UNSEALED;
+
+	return 0;
+}
+
+static int fg_unseal(struct bq_fg_chip *bq, u32 key)
+{
+	int ret;
+	int retry = 0;
+
+	ret = fg_get_seal_state(bq);
+	if (ret)
+		return ret;
+	if (bq->seal_state == SEAL_STATE_UNSEALED)
+		return 0;
+
+	pr_info(":key - 0x%08X\n", key);
+
+	ret = fg_write_word(bq, bq->regs[BQ_FG_REG_CTRL], key & 0xFFFF);
+	if (ret < 0) {
+		pr_err("unable to write unseal key step 1, ret = %d\n", ret);
+		return ret;
+	}
+
+	msleep(5);
+
+	ret = fg_write_word(bq, bq->regs[BQ_FG_REG_CTRL], (key >> 16) & 0xFFFF);
+	if (ret < 0) {
+		pr_err("unable to write unseal key step 2, ret = %d\n", ret);
+		return ret;
+	}
+
+	msleep(5);
+
+	while (retry++ < 1000) {
+		fg_get_seal_state(bq);
+		if (bq->seal_state == SEAL_STATE_UNSEALED) {
+			return 0;
+		}
+		msleep(100);
+	}
+
+	return -1;
+}
+
+
+static int fg_unseal_fa(struct bq_fg_chip *bq, u32 key)
+{
+	int ret;
+	int retry = 0;
+
+	pr_info(":key - %d\n", key);
+
+	ret = fg_write_word(bq, bq->regs[BQ_FG_REG_CTRL], key & 0xFFFF);
+	if (ret < 0) {
+		pr_err("unable to write unseal key step 1, ret = %d\n", ret);
+		return ret;
+	}
+
+	msleep(5);
+
+	ret = fg_write_word(bq, bq->regs[BQ_FG_REG_CTRL], (key >> 16) & 0xFFFF);
+	if (ret < 0) {
+		pr_err("unable to write unseal key step 2, ret = %d\n", ret);
+		return ret;
+	}
+
+	msleep(5);
+
+	while (retry++ < 1000) {
+		fg_get_seal_state(bq);
+		if (bq->seal_state == SEAL_STATE_FA) {
+			return 0;
+		}
+		msleep(10);
+	}
+
+	return -1;
+}
+EXPORT_SYMBOL_GPL(fg_unseal_fa);
+
+static int fg_seal(struct bq_fg_chip *bq)
+{
+	int ret;
+	int retry = 0;
+
+	fg_get_seal_state(bq);
+
+	if (bq->seal_state == SEAL_STATE_SEALED)
+		return 0;
+	msleep(5);
+	ret = fg_write_word(bq, bq->regs[BQ_FG_REG_CTRL], FG_SUBCMD_SEAL);
+
+	if (ret < 0) {
+		pr_err("Failed to send seal command\n");
+		return ret;
+	}
+
+	while (retry++ < 1000) {
+		fg_get_seal_state(bq);
+		if (bq->seal_state == SEAL_STATE_SEALED)
+			return 0;
+		msleep(200);
+	}
+
+	return -1;
+}
+
+
+
+static int fg_check_cfg_update_mode(struct bq_fg_chip *bq)
+{
+	int ret;
+	u16 flags;
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_FLAGS], &flags);
+	if (ret < 0) {
+		return ret;
+	}
+
+	bq->cfg_update_mode = !!(flags & FG_FLAGS_CFGUPMODE);
+
+	return 0;
+
+}
+
+static int fg_check_itpor(struct bq_fg_chip *bq)
+{
+	int ret;
+	u16 flags;
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_FLAGS], &flags);
+	if (ret < 0) {
+		return ret;
+	}
+
+	bq->itpor = !!(flags & FG_FLAGS_ITPOR);
+
+	return 0;
+}
+
+
+static int fg_read_dm_version(struct bq_fg_chip* bq, u8 *ver)
+{
+	int ret;
+	u16 dm_code = 0;
+
+	ret = fg_write_word(bq, bq->regs[BQ_FG_REG_CTRL], FG_SUBCMD_DM_CODE);
+	if (ret < 0) {
+		pr_err("Failed to write control status cmd, ret = %d\n", ret);
+		return ret;
+	}
+
+	msleep(5);
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_CTRL], &dm_code);
+	if (!ret) 
+		*ver = dm_code & 0xFF;
+	return ret;
+}
+
+#define	CFG_UPDATE_POLLING_RETRY_LIMIT	50
+static int fg_dm_pre_access(struct bq_fg_chip *bq)
+{
+	int ret;
+	int i = 0;
+
+	ret = fg_check_init_completed(bq);
+	if (ret < 0)
+		return ret;
+	ret = fg_unseal(bq, FG_DFT_UNSEAL_KEY1);
+	if (ret < 0)
+		return ret;
+
+	ret = fg_write_word(bq, bq->regs[BQ_FG_REG_CTRL], FG_SUBCMD_SET_CFGUPDATE);
+	if (ret < 0)
+		return ret;
+
+	msleep(10);
+
+	while(i++ < CFG_UPDATE_POLLING_RETRY_LIMIT) {
+		ret = fg_check_cfg_update_mode(bq);
+		if (!ret && bq->cfg_update_mode)
+			return 0;
+		msleep(400);
+	}
+
+	pr_err("Failed to enter cfgupdate mode\n");
+
+	return -1;
+}
+EXPORT_SYMBOL_GPL(fg_dm_pre_access);
+
+static int fg_dm_post_access(struct bq_fg_chip *bq)
+{
+	int ret;
+	int i = 0;
+
+
+	ret = fg_write_word(bq, bq->regs[BQ_FG_REG_CTRL],
+						FG_SUBCMD_SOFT_RESET);
+	if (ret < 0)
+		return ret;
+
+	msleep(100);
+
+	while(i++ < CFG_UPDATE_POLLING_RETRY_LIMIT) {
+		ret = fg_check_cfg_update_mode(bq);
+		if (!ret && !bq->cfg_update_mode)
+			break;
+		msleep(100);
+	}
+
+	if (i == CFG_UPDATE_POLLING_RETRY_LIMIT) {
+		pr_err("Failed to exit cfgupdate mode\n");
+		return -1;
+	} else {
+		return fg_seal(bq);
+	}
+}
+EXPORT_SYMBOL_GPL(fg_dm_post_access);
+
+#define	DM_ACCESS_BLOCK_DATA_CHKSUM	0x60
+#define	DM_ACCESS_BLOCK_DATA_CTRL	0x61
+#define	DM_ACCESS_BLOCK_DATA_CLASS	0x3E
+#define	DM_ACCESS_DATA_BLOCK		0x3F
+#define	DM_ACCESS_BLOCK_DATA		0x40
+
+
+static int fg_dm_read_block(struct bq_fg_chip *bq, u8 classid,
+							u8 offset, u8 *buf)
+{
+	int ret;
+	u8 cksum_calc, cksum;
+	u8 blk_offset = offset >> 5;
+
+	pr_info("subclass:%d, offset:%d\n", classid, offset);
+
+	ret = fg_write_byte(bq, DM_ACCESS_BLOCK_DATA_CTRL, 0);
+	if (ret < 0)
+		return ret;
+	msleep(5);
+	ret = fg_write_byte(bq, DM_ACCESS_BLOCK_DATA_CLASS, classid);
+	if (ret < 0)
+		return ret;
+	msleep(5);
+	ret = fg_write_byte(bq, DM_ACCESS_DATA_BLOCK, blk_offset);
+	if (ret < 0)
+		return ret;
+	msleep(5);
+	ret = fg_read_block(bq, DM_ACCESS_BLOCK_DATA, buf, 32);
+	if (ret < 0)
+		return ret;
+	
+	fg_print_buf(__func__, buf, 32);
+
+	msleep(5);
+	cksum_calc = checksum(buf, 32);
+	ret = fg_read_byte(bq, DM_ACCESS_BLOCK_DATA_CHKSUM, &cksum);
+	if (!ret && cksum_calc == cksum)
+		return 0;
+	else
+		return 1;
+}
+EXPORT_SYMBOL_GPL(fg_dm_read_block);
+
+static int fg_dm_write_block(struct bq_fg_chip *bq, u8 classid,
+							u8 offset, u8 *data)
+{
+	int ret;
+	u8 cksum;
+	u8 buf[64];
+	u8 blk_offset = offset >> 5;
+
+	pr_info("subclass:%d, offset:%d\n", classid, offset);
+
+	ret = fg_write_byte(bq, DM_ACCESS_BLOCK_DATA_CTRL, 0);
+	if (ret < 0)
+		return ret;
+	msleep(5);
+	ret = fg_write_byte(bq, DM_ACCESS_BLOCK_DATA_CLASS, classid);
+	if (ret < 0)
+		return ret;
+	msleep(5);
+	ret = fg_write_byte(bq, DM_ACCESS_DATA_BLOCK, blk_offset);
+	if (ret < 0)
+		return ret;
+	ret = fg_write_block(bq, DM_ACCESS_BLOCK_DATA, data, 32);
+	msleep(5);
+
+	fg_print_buf(__func__, data, 32);
+
+	cksum = checksum(data, 32);
+	ret = fg_write_byte(bq, DM_ACCESS_BLOCK_DATA_CHKSUM, cksum);
+	if (ret < 0)
+		return ret;
+	msleep(5);
+
+	ret = fg_write_byte(bq, DM_ACCESS_DATA_BLOCK, blk_offset);
+	if (ret < 0)
+		return ret;
+	msleep(5);
+	ret = fg_read_block(bq, DM_ACCESS_BLOCK_DATA, buf, 32);
+	if (ret < 0)
+		return ret;
+	if (memcpy(data, buf, 32)) {
+		pr_err("Error updating subclass %d offset %d\n",
+				classid, offset);
+		return 1;
+	}
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fg_dm_write_block);
+
+static int fg_read_fw_version(struct bq_fg_chip *bq)
+{
+
+	int ret;
+	u16 version;
+
+	ret = fg_write_word(bq, bq->regs[BQ_FG_REG_CTRL], 0x0002);
+
+	if (ret < 0) {
+		pr_err("Failed to send firmware version subcommand:%d\n", ret);
+		return ret;
+	}
+
+	mdelay(2);
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_CTRL], &version);
+	if (ret < 0) {
+		pr_err("Failed to read firmware version:%d\n", ret);
+		return ret;
+	}
+
+	return version;
+}
+
+
+static int fg_read_status(struct bq_fg_chip *bq)
+{
+	int ret;
+	u16 flags;
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_FLAGS], &flags);
+	if (ret < 0) {
+		return ret;
+	}
+
+	mutex_lock(&bq->data_lock);
+	bq->batt_present	= !!(flags & FG_FLAGS_BAT_DET);
+	bq->batt_ot			= !!(flags & FG_FLAGS_OT);
+	bq->batt_ut			= !!(flags & FG_FLAGS_UT);
+	bq->batt_fc			= !!(flags & FG_FLAGS_FC);
+	bq->batt_soc1		= !!(flags & FG_FLAGS_SOC1);
+	bq->batt_socf		= !!(flags & FG_FLAGS_SOCF);
+	bq->batt_dsg		= !!(flags & FG_FLAGS_DSG);
+	bq->allow_chg		= !!(flags & FG_FLAGS_CHG);
+	mutex_unlock(&bq->data_lock);
+
+	return 0;
+}
+
+
+static int fg_read_rsoc(struct bq_fg_chip *bq)
+{
+	int ret;
+	u16 soc = 0;
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_SOC], &soc);
+	if (ret < 0) {
+		pr_err("could not read RSOC, ret = %d\n", ret);
+		return ret;
+	}
+
+	return soc;
+
+}
+
+static int fg_read_temperature(struct bq_fg_chip *bq)
+{
+	int ret;
+	u16 temp = 0;
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_TEMP], &temp);
+	if (ret < 0) {
+		pr_err("could not read temperature, ret = %d\n", ret);
+		return ret;
+	}
+
+	return temp;
+
+}
+
+static int fg_read_volt(struct bq_fg_chip *bq)
+{
+	int ret;
+	u16 volt = 0;
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_VOLT], &volt);
+	if (ret < 0) {
+		pr_err("could not read voltage, ret = %d\n", ret);
+		return ret;
+	}
+
+	return volt;
+
+}
+
+static int fg_read_current(struct bq_fg_chip *bq, int *curr)
+{
+	int ret;
+	u16 avg_curr = 0;
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_AI], &avg_curr);
+	if (ret < 0) {
+		pr_err("could not read current, ret = %d\n", ret);
+		return ret;
+	}
+	*curr = (int)((s16)avg_curr);
+
+	return ret;
+}
+
+static int fg_read_fcc(struct bq_fg_chip *bq)
+{
+	int ret;
+	u16 fcc;
+
+	if (bq->regs[BQ_FG_REG_FCC] == INVALID_REG_ADDR) {
+		pr_err("FCC command not supported!\n");
+		return 0;
+	}
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_FCC], &fcc);
+
+	if (ret < 0) {
+		pr_err("could not read FCC, ret=%d\n", ret);
+	}
+
+	return fcc;
+}
+
+static int fg_read_dc(struct bq_fg_chip *bq)
+{
+
+	int ret;
+	u16 dc;
+
+	if (bq->regs[BQ_FG_REG_DC] == INVALID_REG_ADDR) {
+		pr_err("DesignCapacity command not supported!\n");
+		return 0;
+	}
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_DC], &dc);
+
+	if (ret < 0) {
+		pr_err("could not read DC, ret=%d\n", ret);
+		return ret;
+	}
+
+	return dc;
+}
+
+
+static int fg_read_rm(struct bq_fg_chip *bq)
+{
+	int ret;
+	u16 rm;
+
+	if (bq->regs[BQ_FG_REG_RM] == INVALID_REG_ADDR) {
+		pr_err("RemainingCapacity command not supported!\n");
+		return 0;
+	}
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_RM], &rm);
+
+	if (ret < 0) {
+		pr_err("could not read DC, ret=%d\n", ret);
+		return ret;
+	}
+
+	return rm;
+
+}
+
+static int fg_read_cyclecount(struct bq_fg_chip *bq)
+{
+	int ret;
+	u16 cc;
+
+	if (bq->regs[BQ_FG_REG_CC] == INVALID_REG_ADDR) {
+		pr_err("Cycle Count not supported!\n");
+		return -1;
+	}
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_CC], &cc);
+
+	if (ret < 0) {
+		pr_err("could not read Cycle Count, ret=%d\n", ret);
+		return ret;
+	}
+
+	return cc;
+}
+
+static int fg_read_tte(struct bq_fg_chip *bq)
+{
+	int ret;
+	u16 tte;
+
+	if (bq->regs[BQ_FG_REG_TTE] == INVALID_REG_ADDR) {
+		pr_err("Time To Empty not supported!\n");
+		return -1;
+	}
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_TTE], &tte);
+
+	if (ret < 0) {
+		pr_err("could not read Time To Empty, ret=%d\n", ret);
+		return ret;
+	}
+
+	if (ret == 0xFFFF)
+		return -ENODATA;
+
+	return tte;
+}
+
+static int fg_get_batt_status(struct bq_fg_chip *bq)
+{
+
+	fg_read_status(bq);
+
+	if (!bq->batt_present)
+		return POWER_SUPPLY_STATUS_UNKNOWN;
+	else if (bq->batt_fc)
+		return POWER_SUPPLY_STATUS_FULL;
+	else if (bq->batt_dsg)
+		return POWER_SUPPLY_STATUS_DISCHARGING;
+	else if (bq->batt_curr > 0)
+		return POWER_SUPPLY_STATUS_CHARGING;
+	else
+		return POWER_SUPPLY_STATUS_NOT_CHARGING;
+
+}
+
+
+static int fg_get_batt_capacity_level(struct bq_fg_chip *bq)
+{
+	if (!bq->batt_present)
+		return POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN;
+	else if (bq->batt_fc)
+		return POWER_SUPPLY_CAPACITY_LEVEL_FULL;
+	else if (bq->batt_soc1)
+		return POWER_SUPPLY_CAPACITY_LEVEL_LOW;
+	else if (bq->batt_socf)
+		return POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL;
+	else
+		return POWER_SUPPLY_CAPACITY_LEVEL_NORMAL;
+
+}
+
+
+static int fg_get_batt_health(struct bq_fg_chip *bq)
+{
+	if (!bq->batt_present)
+		return POWER_SUPPLY_HEALTH_UNKNOWN;
+	else if (bq->batt_ot)
+		return POWER_SUPPLY_HEALTH_OVERHEAT;
+	else if (bq->batt_ut)
+		return POWER_SUPPLY_HEALTH_COLD;
+	else
+		return POWER_SUPPLY_HEALTH_GOOD;
+
+}
+#if 0
+static void parse_dt(struct bq_fg_chip *bq)
+{
+
+}
+#endif
+
+static enum power_supply_property fg_props[] = {
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_CAPACITY_LEVEL,
+	POWER_SUPPLY_PROP_TEMP,
+
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+
+
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_TECHNOLOGY,
+	POWER_SUPPLY_PROP_RESISTANCE_ID,
+	POWER_SUPPLY_PROP_UPDATE_NOW,
+};
+
+static int fg_get_property(struct power_supply *psy, enum power_supply_property psp,
+					union power_supply_propval *val)
+{
+	struct bq_fg_chip *bq = container_of(psy, struct bq_fg_chip, fg_psy);
+	int ret;
+
+	mutex_lock(&bq->update_lock);
+	switch (psp) {
+	case POWER_SUPPLY_PROP_STATUS:
+		val->intval = fg_get_batt_status(bq);
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		ret = fg_read_volt(bq);
+		mutex_lock(&bq->data_lock);
+		if (ret >= 0)
+			bq->batt_volt = ret;
+		val->intval = bq->batt_volt * 1000;
+		mutex_unlock(&bq->data_lock);
+
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = bq->batt_present;
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		mutex_lock(&bq->data_lock);
+		fg_read_current(bq, &bq->batt_curr);
+		val->intval = -bq->batt_curr * 1000;
+
+		mutex_unlock(&bq->data_lock);
+		break;
+
+	case POWER_SUPPLY_PROP_CAPACITY:
+		if (bq->fake_soc >= 0) {
+			val->intval = bq->fake_soc;
+			break;
+		}
+		ret = fg_read_rsoc(bq);
+		mutex_lock(&bq->data_lock);
+		if (ret >= 0)
+			bq->batt_soc = ret;
+		val->intval = bq->batt_soc;
+		mutex_unlock(&bq->data_lock);
+		break;
+
+	case POWER_SUPPLY_PROP_CAPACITY_LEVEL:
+		val->intval = fg_get_batt_capacity_level(bq);
+		break;
+
+	case POWER_SUPPLY_PROP_TEMP:
+		if (bq->fake_temp != -EINVAL) {
+			val->intval = bq->fake_temp;
+			break;
+		}
+		ret = fg_read_temperature(bq);
+		mutex_lock(&bq->data_lock);
+		if (ret > 0)
+			bq->batt_temp = ret;
+		val->intval = bq->batt_temp - 2730;
+		mutex_unlock(&bq->data_lock);
+		break;
+
+	case POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW:
+		ret = fg_read_tte(bq);
+		mutex_lock(&bq->data_lock);
+		if (ret >=0)
+			bq->batt_tte = ret;
+
+		val->intval = bq->batt_tte;
+		mutex_unlock(&bq->data_lock);
+		break;
+
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		ret = fg_read_fcc(bq);
+		mutex_lock(&bq->data_lock);
+		if (ret > 0)
+			bq->batt_fcc = ret;
+		val->intval = bq->batt_fcc * 1000;
+		mutex_unlock(&bq->data_lock);
+		break;
+
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		ret = fg_read_dc(bq);
+		mutex_lock(&bq->data_lock);
+		if (ret > 0)
+			bq->batt_dc = ret;
+		val->intval = bq->batt_dc * 1000;
+		mutex_unlock(&bq->data_lock);
+		break;
+
+	case POWER_SUPPLY_PROP_CYCLE_COUNT:
+		ret = fg_read_cyclecount(bq);
+		mutex_lock(&bq->data_lock);
+		if (ret >= 0)
+			bq->batt_cyclecnt = ret;
+		val->intval = bq->batt_cyclecnt;
+		mutex_unlock(&bq->data_lock);
+		break;
+
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = fg_get_batt_health(bq);
+		break;
+
+	case POWER_SUPPLY_PROP_TECHNOLOGY:
+		val->intval = POWER_SUPPLY_TECHNOLOGY_LIPO;
+		break;
+
+	case POWER_SUPPLY_PROP_RESISTANCE_ID:
+		val->intval = bq->connected_rid ;
+		break;
+	case POWER_SUPPLY_PROP_UPDATE_NOW:
+		val->intval = 0;
+		break;
+
+	default:
+		mutex_unlock(&bq->update_lock);
+		return -EINVAL;
+	}
+	mutex_unlock(&bq->update_lock);
+	return 0;
+}
+static void fg_dump_registers(struct bq_fg_chip *bq);
+
+static int fg_set_property(struct power_supply *psy,
+				       enum power_supply_property prop,
+				       const union power_supply_propval *val)
+{
+	struct bq_fg_chip *bq = container_of(psy, struct bq_fg_chip,
+									fg_psy);
+	switch (prop) {
+	case POWER_SUPPLY_PROP_TEMP:
+		bq->fake_temp = val->intval;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		bq->fake_soc = val->intval;
+		power_supply_changed(&bq->fg_psy);
+		break;
+	case POWER_SUPPLY_PROP_UPDATE_NOW:
+		fg_dump_registers(bq);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int fg_prop_is_writeable(struct power_supply *psy,
+				       enum power_supply_property prop)
+{
+	int ret;
+
+	switch (prop) {
+	case POWER_SUPPLY_PROP_TEMP:
+	case POWER_SUPPLY_PROP_CAPACITY:
+	case POWER_SUPPLY_PROP_UPDATE_NOW:
+		ret = 1;
+		break;
+	default:
+		ret = 0;
+		break;
+	}
+	return ret;
+}
+
+
+
+static void fg_external_power_changed(struct power_supply *psy)
+{
+#if 0
+	struct bq_fg_chip *bq = container_of(psy, struct bq_fg_chip, fg_psy);
+
+	cancel_delayed_work(&bq->monitor_work);
+	schedule_delayed_work(&bq->monitor_work, 0);
+#endif
+
+}
+
+static int fg_psy_register(struct bq_fg_chip *bq)
+{
+	int ret;
+
+	bq->fg_psy.name = "bms";
+	bq->fg_psy.type = POWER_SUPPLY_TYPE_BMS;
+	bq->fg_psy.properties = fg_props;
+	bq->fg_psy.num_properties = ARRAY_SIZE(fg_props);
+	bq->fg_psy.get_property = fg_get_property;
+	bq->fg_psy.set_property = fg_set_property;
+	bq->fg_psy.external_power_changed = fg_external_power_changed;
+	bq->fg_psy.property_is_writeable = fg_prop_is_writeable;
+
+
+	ret = power_supply_register(bq->dev, &bq->fg_psy);
+	if (ret < 0) {
+		pr_err("Failed to register fg_psy:%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+
+static void fg_psy_unregister(struct bq_fg_chip *bq)
+{
+
+	power_supply_unregister(&bq->fg_psy);
+}
+
+
+static int fg_change_chem_id(struct bq_fg_chip *bq, u16 new_id)
+{
+	int ret;
+	u16 old_id;
+
+	int i;
+
+	ret = fg_write_word(bq, bq->regs[BQ_FG_REG_CTRL], FG_SUBCMD_CHEM_ID);
+	if (ret < 0) {
+		pr_err("Failed to write chemid subcmd, ret = %d\n", ret);
+		return ret;
+	}
+
+	msleep(5);
+
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_CTRL], &old_id);
+	if (ret < 0) {
+		pr_err("Failed to read control status, ret = %d\n", ret);
+		return ret;
+	}
+
+	if (new_id == old_id) {
+		pr_info("new chemid is same as old one, skip change\n");
+		return 0;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(batt_chem_id_arr); i++) {
+		if (new_id == batt_chem_id_arr[i].id) 
+			break;
+	}
+
+	if (i == ARRAY_SIZE(batt_chem_id_arr)) {
+		pr_err("not supported chem_id %d\n", new_id);
+		return -1;
+	}
+
+	msleep(5);
+	ret = fg_dm_pre_access(bq);
+	if (ret < 0)
+		return ret;
+	msleep(5);
+	ret = fg_write_word(bq, bq->regs[BQ_FG_REG_CTRL], batt_chem_id_arr[i].cmd);
+	if (ret < 0) {
+		pr_err("Failed to send chem_id command, ret=%d\n", ret);
+		fg_dm_post_access(bq);
+		return ret;
+	}
+
+	msleep(5);
+	ret = fg_dm_post_access(bq);
+	if (ret < 0)
+		return ret;
+
+	msleep(2000);
+	ret = fg_read_word(bq, bq->regs[BQ_FG_REG_CTRL], &old_id);
+	if (ret < 0) {
+		pr_err("Failed to read control status, ret = %d\n", ret);
+		return ret;
+	}
+
+	if (new_id == old_id) {
+		pr_info("chem ID changed successfully\n");
+		return 0;
+	} else {
+		return -1;
+	}
+}
+EXPORT_SYMBOL_GPL(fg_change_chem_id);
+
+static int fg_check_update_necessary(struct bq_fg_chip *bq)
+{
+	int ret;
+	u8 dm_ver = 0xFF;
+
+	ret = fg_check_itpor(bq);
+	if (!ret && bq->itpor)
+		return UPDATE_REASON_FG_RESET;
+
+	ret = fg_read_dm_version(bq, &dm_ver);
+	if (!ret && dm_ver < bqfs_image[bq->batt_id].version)
+		return UPDATE_REASON_NEW_VERSION;
+	else
+		return 0;
+}
+
+static bool fg_update_bqfs_execute_cmd(struct bq_fg_chip *bq,
+										const bqfs_cmd_t *cmd)
+{
+	int ret;
+	int i;
+	u8	tmp_buf[CMD_MAX_DATA_SIZE];
+
+	switch (cmd->cmd_type) {
+	case CMD_R:
+		ret = fg_read_block(bq, cmd->reg, (u8 *)&cmd->data.bytes, cmd->data_len);
+		if (ret < 0)
+			return false;
+		else
+			return true;
+		break;
+	case CMD_W:
+		ret = fg_write_block(bq, cmd->reg, (u8 *)&cmd->data.bytes, cmd->data_len);
+		if (ret < 0)
+			return false;
+		else
+			return true;
+		break;
+	case CMD_C:
+		if (fg_read_block(bq, cmd->reg, tmp_buf, cmd->data_len) < 0)
+			return false;
+		if (memcmp(tmp_buf, cmd->data.bytes, cmd->data_len)) {
+			pr_info("CMD_C failed at line %d\n", cmd->line_num);
+			for(i = 0; i < cmd->data_len; i++) {
+				pr_err("Read: %02X, Cmp:%02X", tmp_buf[i], cmd->data.bytes[i]);
+			}
+			return false;
+		}
+
+		return true;
+		break;
+	case CMD_X:
+		mdelay(cmd->data.delay);
+		return true;
+		break;
+	default:
+		pr_err("Unsupported command at line %d\n", cmd->line_num);
+		return false;
+	}
+
+}
+EXPORT_SYMBOL_GPL(fg_update_bqfs_execute_cmd);
+
+static void fg_update_bqfs(struct bq_fg_chip *bq)
+{
+	int i;
+	const bqfs_cmd_t *image;
+	int reason = 0;
+
+
+	if (bq->force_update == ~BQFS_UPDATE_KEY)
+		reason = UPDATE_REASON_FORCED;
+	else
+		reason = fg_check_update_necessary(bq);
+
+	if (!reason) {
+		pr_info("Fuel Gauge parameter no need update, ignored\n");
+		return;
+	}
+
+	if (bq->batt_id >= ARRAY_SIZE(bqfs_image) ||
+		bq->batt_id < 0) {
+		pr_err("batt_id is out of range");
+		return;
+	}
+	fg_dm_pre_access(bq);
+
+	pr_err("Fuel Gauge parameter update, reason:%s, version:%d, batt_id=%d Start...\n",
+			update_reason_str[reason - 1], bqfs_image[bq->batt_id].version, bq->batt_id);
+
+	mutex_lock(&bq->update_lock);
+	image = bqfs_image[bq->batt_id].bqfs_image;
+	for (i = 0; i < bqfs_image[bq->batt_id].array_size; i++) {
+		if (!fg_update_bqfs_execute_cmd(bq, &image[i])) {
+			mutex_unlock(&bq->update_lock);
+			pr_err("Failed at command: %d\n", i);
+			fg_dm_post_access(bq);
+			return;
+		}
+		mdelay(5);
+	}
+	mutex_unlock(&bq->update_lock);
+
+	pr_err("Done!\n");
+
+	fg_dm_post_access(bq);
+	return;
+
+}
+EXPORT_SYMBOL_GPL(fg_update_bqfs);
+
+static const u8 fg_dump_regs[] = {
+	0x00, 0x02, 0x04, 0x06,
+	0x08, 0x0A, 0x0C, 0x0E,
+	0x10, 0x16, 0x18, 0x1A,
+	0x1C, 0x1E, 0x20, 0x28,
+	0x2A, 0x2C, 0x2E, 0x30,
+	0x66, 0x68, 0x6C, 0x6E,
+	0x70,
+};
+
+static int show_registers(struct seq_file *m, void *data)
+{
+	struct bq_fg_chip *bq = m->private;
+	int i;
+	int ret;
+	u16 val = 0;
+
+	for (i = 0; i < ARRAY_SIZE(fg_dump_regs); i++) {
+		msleep(5);
+		ret = fg_read_word(bq, fg_dump_regs[i], &val);
+		if (!ret)
+			seq_printf(m, "Reg[%02X] = 0x%04X\n", 
+						fg_dump_regs[i], val);
+	}
+	return 0;
+}
+
+
+static int reg_debugfs_open(struct inode *inode, struct file *file)
+{
+	struct bq_fg_chip *bq = inode->i_private;
+
+	return single_open(file, show_registers, bq);
+}
+
+static const struct file_operations reg_debugfs_ops = {
+	.owner		= THIS_MODULE,
+	.open		= reg_debugfs_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static void create_debugfs_entry(struct bq_fg_chip *bq)
+{
+	bq->debug_root = debugfs_create_dir("bq_fg", NULL);
+	if (!bq->debug_root)
+		pr_err("Failed to create debug dir\n");
+
+	if (bq->debug_root) {
+
+		debugfs_create_file("registers", S_IFREG | S_IRUGO,
+						bq->debug_root, bq, &reg_debugfs_ops);
+
+		debugfs_create_x32("fake_soc",
+					  S_IFREG | S_IWUSR | S_IRUGO,
+					  bq->debug_root,
+					  &(bq->fake_soc));
+
+		debugfs_create_x32("fake_temp",
+					  S_IFREG | S_IWUSR | S_IRUGO,
+					  bq->debug_root,
+					  &(bq->fake_temp));
+
+		debugfs_create_x32("skip_reads",
+					  S_IFREG | S_IWUSR | S_IRUGO,
+					  bq->debug_root,
+					  &(bq->skip_reads));
+		debugfs_create_x32("skip_writes",
+					  S_IFREG | S_IWUSR | S_IRUGO,
+					  bq->debug_root,
+					  &(bq->skip_writes));
+	}
+}
+
+static ssize_t fg_attr_show_Ra_table(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bq_fg_chip *bq = i2c_get_clientdata(client);
+
+	int ret;
+	u8 rd_buf[64];
+	u8 temp_buf[100];
+	int len, i, idx;
+	u8 *err_str[] = {
+		"Failed to enter configure mode",
+		"Failed to Read Ra Table",
+		"Failed to exit configure mode",
+	};
+
+	memset(buf, 0, 64);
+	mutex_lock(&bq->update_lock);
+	ret = fg_dm_pre_access(bq);
+	if (ret) {
+		sprintf(buf,"%s", err_str[0]);
+		mutex_unlock(&bq->update_lock);
+		return strlen(err_str[0]);
+	}
+
+	ret = fg_dm_read_block(bq, 89, 0, rd_buf);
+	if (ret) {
+		sprintf(buf,"%s", err_str[1]);
+		fg_dm_post_access(bq);
+		mutex_unlock(&bq->update_lock);
+		return strlen(err_str[1]);
+	}
+
+	fg_dm_post_access(bq);
+
+	idx = 0;
+	for (i = 0; i < 30; i++) {
+		len = sprintf(temp_buf, "%02X ", rd_buf[i]);
+		memcpy(&buf[idx], temp_buf, len);
+		idx += len;
+	}
+	mutex_unlock(&bq->update_lock);
+	return idx;
+}
+
+static ssize_t fg_attr_show_Qmax(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bq_fg_chip *bq = i2c_get_clientdata(client);
+
+	int ret;
+	u8 rd_buf[64];
+	int len;
+	u8 *err_str[] = {
+		"Failed to enter configure mode",
+		"Failed to Qmax",
+	};
+
+	memset(buf, 0, 64);
+	mutex_lock(&bq->update_lock);
+	ret = fg_dm_pre_access(bq);
+	if (ret) {
+		sprintf(buf,"%s", err_str[0]);
+		mutex_unlock(&bq->update_lock);
+		return strlen(err_str[0]);
+	}
+
+	ret = fg_dm_read_block(bq, 82, 0, rd_buf);
+	if (ret) {
+		sprintf(buf,"%s", err_str[1]);
+		fg_dm_post_access(bq);
+		mutex_unlock(&bq->update_lock);
+		return strlen(err_str[1]);
+	}
+
+	len = sprintf(buf, "Qmax Cell 0 = %d\n", (rd_buf[0] << 8) | rd_buf[1]);
+	fg_dm_post_access(bq);
+
+	mutex_unlock(&bq->update_lock);
+	return len;
+}
+
+static ssize_t fg_attr_store_update(struct device *dev,
+				struct device_attribute *attr, const char *buf, size_t count)
+{
+
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bq_fg_chip *bq = i2c_get_clientdata(client);
+	unsigned int key = 0;
+
+	sscanf(buf, "%x", &key);
+	if (key == BQFS_UPDATE_KEY) {
+		bq->force_update = ~key;
+		schedule_work(&bq->update_work);
+	}
+	return count;
+}
+
+static ssize_t fg_attr_show_dmcode(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bq_fg_chip *bq = i2c_get_clientdata(client);
+
+	int ret;
+	u8 ver;
+
+	ret = fg_read_dm_version(bq, &ver);
+	if (!ret)
+		return sprintf(buf, "0x%02X\n", ver);
+	else
+		return sprintf(buf, "Read DM code error");
+}
+
+
+
+static DEVICE_ATTR(RaTable, S_IRUGO, fg_attr_show_Ra_table, NULL);
+static DEVICE_ATTR(Qmax, S_IRUGO, fg_attr_show_Qmax, NULL);
+static DEVICE_ATTR(update, S_IWUSR, NULL, fg_attr_store_update);
+static DEVICE_ATTR(dmcode, S_IRUGO, fg_attr_show_dmcode, NULL);
+
+static struct attribute *fg_attributes[] = {
+	&dev_attr_RaTable.attr,
+	&dev_attr_Qmax.attr,
+	&dev_attr_update.attr,
+	&dev_attr_dmcode.attr,
+	NULL,
+};
+
+static const struct attribute_group fg_attr_group = {
+	.attrs = fg_attributes,
+};
+
+static void fg_update_bqfs_workfunc(struct work_struct *work)
+{
+		struct bq_fg_chip *bq = container_of(work,
+							struct bq_fg_chip, update_work);
+
+		fg_update_bqfs(bq);
+}
+
+static void fg_dump_registers(struct bq_fg_chip *bq)
+{
+	int i;
+	int ret;
+	u16 val;
+
+	for (i = 0; i < ARRAY_SIZE(fg_dump_regs); i++) {
+		msleep(5);
+		ret = fg_read_word(bq, fg_dump_regs[i], &val);
+		if (!ret)
+			printk("Reg[%02X] = 0x%04X ", fg_dump_regs[i], val);
+	}
+	pr_info("bq27426 fg_dump_registers\n");
+}
+
+static irqreturn_t fg_irq_thread(int irq, void *dev_id)
+{
+	struct bq_fg_chip *bq = dev_id;
+	bool last_batt_present;
+
+	mutex_lock(&bq->irq_complete);
+	bq->irq_waiting = true;
+	if (!bq->resume_completed) {
+
+		if (!bq->irq_disabled) {
+			disable_irq_nosync(irq);
+			bq->irq_disabled = true;
+		}
+		mutex_unlock(&bq->irq_complete);
+		return IRQ_HANDLED;
+	}
+	bq->irq_waiting = false;
+
+	last_batt_present = bq->batt_present;
+
+	mutex_lock(&bq->update_lock);
+	fg_read_status(bq);
+	mutex_unlock(&bq->update_lock);
+
+
+
+	pr_info("itpor=%d, cfg_mode = %d, seal_state=%d, batt_present=%d\n",
+			bq->itpor, bq->cfg_update_mode, bq->seal_state, bq->batt_present);
+
+	if (!last_batt_present && bq->batt_present ) {
+		pr_info("Battery inserted\n");
+	} else if (last_batt_present && !bq->batt_present) {
+		pr_info("Battery removed\n");
+		bq->batt_soc	= -ENODATA;
+		bq->batt_fcc	= -ENODATA;
+		bq->batt_rm		= -ENODATA;
+		bq->batt_volt	= -ENODATA;
+		bq->batt_curr	= -ENODATA;
+		bq->batt_temp	= -ENODATA;
+		bq->batt_cyclecnt = -ENODATA;
+	}
+
+	if (bq->batt_present) {
+		mutex_lock(&bq->update_lock);
+
+		bq->batt_soc = fg_read_rsoc(bq);
+		bq->batt_volt = fg_read_volt(bq);
+		fg_read_current(bq, &bq->batt_curr);
+		bq->batt_temp = fg_read_temperature(bq);
+		bq->batt_rm = fg_read_rm(bq);
+
+		mutex_unlock(&bq->update_lock);
+		pr_err("RSOC:%d, Volt:%d, Current:%d, Temperature:%d, connected_rid = %d\n",
+			bq->batt_soc, bq->batt_volt, bq->batt_curr, bq->batt_temp - 2730, bq->connected_rid);
+	}
+
+	power_supply_changed(&bq->fg_psy);
+	mutex_unlock(&bq->irq_complete);
+
+	return IRQ_HANDLED;
+}
+
+
+static void determine_initial_status(struct bq_fg_chip *bq)
+{
+	fg_irq_thread(bq->client->irq, bq);
+}
+static void convert_rid2battid(struct bq_fg_chip *bq)
+{
+
+	if (bq->connected_rid > 400 && bq->connected_rid < 600) {
+		bq->batt_id = 3;
+	} else if (bq->connected_rid > 220 && bq->connected_rid < 385) {
+		bq->batt_id = 2;
+	} else if (bq->connected_rid > 60 && bq->connected_rid < 140) {
+		bq->batt_id = 1;
+	} else if (bq->connected_rid > 10 && bq->connected_rid < 50) {
+		bq->batt_id = 0;
+	} else {
+		bq->batt_id = 1;
+	}
+}
+
+
+#define SMB_VTG_MIN_UV		1800000
+#define SMB_VTG_MAX_UV		1800000
+static int fg_parse_batt_id(struct bq_fg_chip *bq)
+{
+	int rc = 0, rpull = 0, vref = 0;
+	int64_t denom, batt_id_uv;
+	struct device_node *node = bq->dev->of_node;
+	struct qpnp_vadc_result result;
+
+	bq->vdd = regulator_get(bq->dev, "vdd");
+	if (IS_ERR(bq->vdd)) {
+		pr_err("Regulator get failed vdd rc=%d\n", rc);
+
+	}
+
+	if (regulator_count_voltages(bq->vdd) > 0) {
+		rc = regulator_set_voltage(bq->vdd, SMB_VTG_MIN_UV,
+					   SMB_VTG_MAX_UV);
+		if (rc) {
+			pr_err("Regulator set_vtg failed vdd rc=%d\n", rc);
+		}
+	}
+
+	rc = regulator_enable(bq->vdd);
+	if (rc) {
+		pr_err("Regulator vdd enable failed rc=%d\n", rc);
+	}
+
+	rc = of_property_read_u32(node, "ti,batt-id-vref-uv", &vref);
+	if (rc < 0) {
+		pr_err("Couldn't read batt-id-vref-uv rc=%d\n", rc);
+		return rc;
+	}
+
+
+	rc = of_property_read_u32(node, "ti,batt-id-rpullup-kohm", &rpull);
+	if (rc < 0) {
+		pr_err("Couldn't read batt-id-rpullup-kohm rc=%d\n", rc);
+		return rc;
+	}
+	pr_debug("fg_parse_batt_id begin read battery ID \n");
+	rc = qpnp_vadc_read(bq->vadc_dev, P_MUX2_1_1, &result);
+	if (rc) {
+		pr_err("error reading batt id channel = %d, rc = %d\n",
+					LR_MUX2_BAT_ID, rc);
+		return rc;
+	}
+
+
+	batt_id_uv = result.physical;
+
+
+	pr_debug("fg_parse_batt_id  batt_id_uv = %lld\n",batt_id_uv);
+
+	if (batt_id_uv == 0) {
+		pr_err("batt_id_uv = 0, batt-id grounded using same profile\n");
+		return 0;
+	}
+
+	denom = div64_s64(vref * 1000000LL, batt_id_uv) - 1000000LL;
+
+
+	pr_debug("fg_parse_batt_id  denom = %lld,rpull=%d\n",denom,rpull);
+	if (denom == 0) {
+		pr_err("smb_parse_batt_id batt id connector might be open, return 0 kohms");
+		return 0;
+	}
+	bq->connected_rid = div64_s64(rpull * 1000000LL + denom/2, denom);
+	pr_err("batt_id_voltage = %lld, connected_rid = %d\n",
+			batt_id_uv, bq->connected_rid);
+
+	convert_rid2battid(bq);
+
+	return 0;
+}
+
+static int bq_parse_dt(struct bq_fg_chip *bq)
+{
+#if 0
+	int rc;
+	struct device_node *node = bq->dev->of_node;
+	const char *batt_type_str_a, *batt_type_str_b;
+
+	if (!node) {
+		dev_err(bq->dev, "device tree info. missing\n");
+		return -EINVAL;
+	}
+
+		 bq->force_select_profile_b = of_property_read_bool(node,
+					"agassiz,force-select-profile-b");
+		 pr_debug("force select profile b is support(%d)\n",
+					bq->force_select_profile_b);
+
+		 rc = of_property_read_string(node, "ti,battery-type-a",
+									    &batt_type_str_a);
+		 if (rc) {
+				pr_err("Not support battery type A: %d\n", rc);
+				rc = 0;
+		  } else
+		bq->batt_type_a = batt_type_str_a;
+
+		 rc = of_property_read_string(node, "ti,battery-type-b",
+									    &batt_type_str_b);
+		 if (rc) {
+				pr_err("Not support battery type B: %d\n", rc);
+				rc = 0;
+		  } else
+		bq->batt_type_b = batt_type_str_b;
+
+	bq->rsense_10mohm = of_property_read_bool(node, "ti,rsense-10mhom");
+
+	if (of_property_read_bool(node, "ti,batt-profile-select")) {
+		rc = smb_parse_batt_id(chip);
+		if (rc < 0) {
+			if (rc != -EPROBE_DEFER)
+				pr_err("Unable to parse batt-id rc=%d\n", rc);
+			return rc;
+		}
+	}
+	pr_err("bq_parse_dt end\n");
+#endif
+
+	return 0;
+}
+
+static int bq_fg_probe(struct i2c_client *client,
+							const struct i2c_device_id *id)
+{
+
+	int ret;
+	struct bq_fg_chip *bq;
+	u8 *regs;
+
+	bq = devm_kzalloc(&client->dev, sizeof(*bq), GFP_KERNEL);
+
+	if (!bq) {
+		pr_err("Could not allocate memory\n");
+		return -ENOMEM;
+	}
+
+	bq->dev = &client->dev;
+	bq->client = client;
+	bq->chip = id->driver_data;
+
+	bq->batt_soc	= -ENODATA;
+	bq->batt_fcc	= -ENODATA;
+	bq->batt_rm		= -ENODATA;
+	bq->batt_dc		= -ENODATA;
+	bq->batt_volt	= -ENODATA;
+	bq->batt_temp	= -ENODATA;
+	bq->batt_curr	= -ENODATA;
+	bq->batt_cyclecnt = -ENODATA;
+
+	bq->fake_soc 	= -EINVAL;
+	bq->fake_temp	= -EINVAL;
+
+	if (bq->chip == BQ27426) {
+		regs = bq27426_regs;
+	} else {
+		pr_err("unexpected fuel gauge: %d\n", bq->chip);
+		regs = bq27426_regs;
+	}
+
+	memcpy(bq->regs, regs, NUM_REGS);
+
+	i2c_set_clientdata(client, bq);
+
+	mutex_init(&bq->i2c_rw_lock);
+	mutex_init(&bq->data_lock);
+	mutex_init(&bq->update_lock);
+	mutex_init(&bq->irq_complete);
+
+	bq->resume_completed = true;
+	bq->irq_waiting = false;
+
+	bq->vadc_dev = qpnp_get_vadc(bq->dev, "batt_id");
+	if (IS_ERR(bq->vadc_dev)) {
+		ret = PTR_ERR(bq->vadc_dev);
+		if (ret == -EPROBE_DEFER)
+			pr_err("vadc not found - defer rc=%d\n", ret);
+		else
+			pr_err("vadc property missing, rc=%d\n", ret);
+
+		return ret;
+	}
+	ret = bq_parse_dt(bq);
+	if (ret < 0) {
+		dev_err(&client->dev, "Unable to parse DT nodes\n");
+
+	}
+	INIT_WORK(&bq->update_work, fg_update_bqfs_workfunc);
+
+	fg_parse_batt_id(bq);
+
+	fg_update_bqfs(bq);
+
+	if (client->irq) {
+		ret = devm_request_threaded_irq(&client->dev, client->irq, NULL,
+			fg_irq_thread,
+			IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+			"bq fuel gauge irq", bq);
+		if (ret < 0) {
+			pr_err("request irq for irq=%d failed, ret = %d\n", client->irq, ret);
+			goto err_1;
+		}
+		enable_irq_wake(client->irq);
+	}
+
+	device_init_wakeup(bq->dev, 1);
+
+	bq->fw_ver = fg_read_fw_version(bq);
+
+	fg_psy_register(bq);
+
+	create_debugfs_entry(bq);
+	ret = sysfs_create_group(&bq->dev->kobj, &fg_attr_group);
+	if (ret) {
+		pr_err("Failed to register sysfs, err:%d\n", ret);
+	}
+
+	determine_initial_status(bq);
+
+	pr_err("bq fuel gauge probe successfully, %s FW ver:%d\n",
+			device2str[bq->chip], bq->fw_ver);
+
+	return 0;
+
+err_1:
+	fg_psy_unregister(bq);
+	return ret;
+}
+
+
+static inline bool is_device_suspended(struct bq_fg_chip *bq)
+{
+	return !bq->resume_completed;
+}
+
+
+static int bq_fg_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bq_fg_chip *bq = i2c_get_clientdata(client);
+
+	mutex_lock(&bq->irq_complete);
+	bq->resume_completed = false;
+	mutex_unlock(&bq->irq_complete);
+
+	return 0;
+}
+
+static int bq_fg_suspend_noirq(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bq_fg_chip *bq = i2c_get_clientdata(client);
+
+	if (bq->irq_waiting) {
+		pr_err_ratelimited("Aborting suspend, an interrupt was detected while suspending\n");
+		return -EBUSY;
+	}
+	return 0;
+
+}
+
+
+static int bq_fg_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct bq_fg_chip *bq = i2c_get_clientdata(client);
+
+	mutex_lock(&bq->irq_complete);
+	bq->resume_completed = true;
+	if (bq->irq_waiting) {
+		bq->irq_disabled = false;
+		enable_irq(client->irq);
+		mutex_unlock(&bq->irq_complete);
+		fg_irq_thread(client->irq, bq);
+	} else {
+		mutex_unlock(&bq->irq_complete);
+	}
+
+	power_supply_changed(&bq->fg_psy);
+
+	return 0;
+
+
+}
+
+static int bq_fg_remove(struct i2c_client *client)
+{
+	struct bq_fg_chip *bq = i2c_get_clientdata(client);
+
+	fg_psy_unregister(bq);
+
+	mutex_destroy(&bq->data_lock);
+	mutex_destroy(&bq->i2c_rw_lock);
+	mutex_destroy(&bq->update_lock);
+	mutex_destroy(&bq->irq_complete);
+
+	debugfs_remove_recursive(bq->debug_root);
+	sysfs_remove_group(&bq->dev->kobj, &fg_attr_group);
+
+	return 0;
+
+}
+
+static void bq_fg_shutdown(struct i2c_client *client)
+{
+	pr_info("bq fuel gauge driver shutdown!\n");
+}
+
+static struct of_device_id bq_fg_match_table[] = {
+	{.compatible = "ti,bq27426",},
+	{},
+};
+MODULE_DEVICE_TABLE(of,bq_fg_match_table);
+
+static const struct i2c_device_id bq_fg_id[] = {
+	{ "bq27426", BQ27426 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, bq_fg_id);
+
+static const struct dev_pm_ops bq_fg_pm_ops = {
+	.resume		= bq_fg_resume,
+	.suspend_noirq = bq_fg_suspend_noirq,
+	.suspend	= bq_fg_suspend,
+};
+
+static struct i2c_driver bq_fg_driver = {
+	.driver 	= {
+		.name 	= "bq_fg",
+		.owner 	= THIS_MODULE,
+		.of_match_table = bq_fg_match_table,
+		.pm		= &bq_fg_pm_ops,
+	},
+	.id_table	= bq_fg_id,
+
+	.probe		= bq_fg_probe,
+	.remove		= bq_fg_remove,
+	.shutdown	= bq_fg_shutdown,
+
+};
+
+module_i2c_driver(bq_fg_driver);
+
+MODULE_DESCRIPTION("TI BQ2742x Gauge Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Texas Instruments");
diff --git a/drivers/power/supply/qcom/bq27426_gmfs_coslight.h b/drivers/power/supply/qcom/bq27426_gmfs_coslight.h
new file mode 100644
index 000000000000..115e1c56b039
--- /dev/null
+++ b/drivers/power/supply/qcom/bq27426_gmfs_coslight.h
@@ -0,0 +1,971 @@
+/*****************************************************************************
+* Copyright 2010 Texas Instruments Corporation, All Rights Reserved.
+* Copyright (C) 2018 XiaoMi, Inc.
+* TI makes NO WARRANTY as to software products, which are supplied "AS-IS"
+*****************************************************************************/
+
+/*****************************************************************************
+*     This code is automatically generated from bqfs/dffs file.              *
+*          DO NOT MODIFY THIS FILE DIRECTLY                                  *
+*****************************************************************************/
+
+#include "bqfs_cmd_type.h"
+
+const bqfs_cmd_t bqfs_coslight[] = {
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x01, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x26, 0x04} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x02, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x02, 0x02} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x13, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 1100},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x02, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x02, 0x26, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA5} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x02, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA5} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x24, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x19, 0x28, 0x63, 0x5F, 0xFF, 0x63, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x68} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x24, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x68} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x31, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x0A, 0x0F, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x31, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x40, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x64, 0x79, 0x0F, 0x86, 0x23, 0x10, 0x00, 0x14, 0x04, 0x00, 0x09, 0x04, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x0F} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x40, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x0F} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x44, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x32, 0x01, 0xC2, 0x30, 0x00, 0x03, 0x08, 0x98, 0x01, 0x00, 0x3C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x44, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x01, 0xF4, 0x00, 0x1E, 0xC8, 0x14, 0x08, 0x00, 0x3C, 0x0E, 0x10, 0x00, 0x0A, 0x46, 0x05, 0x14, 0x05, 0x0F, 0x03, 0x20, 0x7F, 0xFF, 0x00, 0xF0, 0x46, 0x50, 0x18, 0x01, 0x90, 0x00, 0x64, 0x19} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xE4} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xE4} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xDC, 0x5C, 0x60, 0x00, 0x7D, 0x00, 0x04, 0x03, 0x19, 0x25, 0x0F, 0x14, 0x0A, 0x78, 0x60, 0x28, 0x01, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x43, 0x80, 0x04, 0x01, 0x14, 0x00, 0x08, 0x0B, 0xB8, 0x01} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDB} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDB} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x02} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x2C, 0x0A, 0x01, 0x0A, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x64, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0xD0, 0x01, 0x03, 0x5A, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x59} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x02} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x59} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x51, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x01, 0x77, 0x01, 0x2C, 0x07, 0xD0, 0x00, 0x3C, 0x3C, 0x01, 0xB3, 0xB3, 0x01, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x13} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x51, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x13} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x52, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x41, 0x0A, 0x00, 0x00, 0x32, 0x81, 0x0C, 0x08, 0x2E, 0x52, 0x0C, 0x1C, 0x00, 0x64, 0x00, 0x32, 0x00, 0x14, 0x03, 0xE8, 0x01, 0x00, 0x9A, 0x00, 0x05, 0xFF, 0xCD, 0xFF, 0xCC, 0x00, 0x02, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x77} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x52, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x77} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x15, 0x14, 0x11, 0x28, 0xDA, 0xDC, 0xE1, 0xE0, 0xE0, 0xE1, 0xE3, 0xE3, 0xE2, 0xE5, 0xE7, 0xE2, 0xDE, 0xED, 0xED, 0xE5, 0xE6, 0xE9, 0xEF, 0xF1, 0xF3, 0xF5, 0xF7, 0xF8, 0xF9, 0xFA, 0xFA, 0xFE} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x01} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x01} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xFA, 0xF4, 0xF8, 0xF5, 0xF2, 0xF1, 0xF5, 0xFA, 0xFC, 0xDD, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xFD, 0x88, 0x03, 0x5D, 0x3D, 0xF2, 0x08, 0x13, 0x0A, 0xEC, 0x00, 0x13, 0x09, 0x10, 0x31, 0x56, 0xEA, 0xF5, 0x06, 0x07, 0xBC, 0x9F, 0x0D, 0xF9, 0xF8, 0xF0, 0xF5, 0xF1, 0xEE, 0xEE, 0xBA, 0xB6} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xC0} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xC0} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x1F, 0xE0, 0x0F, 0xE9, 0x8C, 0x47, 0x3D, 0x03, 0x7C, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF8} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF8} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x55, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xFF, 0xEE, 0x00, 0x70, 0xF3, 0xA3, 0x3E, 0xC4, 0xE5, 0x0E, 0xF2, 0xFB, 0xC2, 0x37, 0xFC, 0xC3, 0xB7, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xBB} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x55, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xBB} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6C, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xFE, 0x47, 0x00, 0xD7, 0x19, 0x49, 0x13, 0xD4, 0x00, 0xCA, 0xF8, 0xFF, 0xE4, 0xF6, 0x26, 0x7D, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x1F} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6C, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x1F} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x59, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x47, 0x00, 0x31, 0x00, 0x4F, 0x00, 0x43, 0x00, 0x58, 0x00, 0x55, 0x00, 0x59, 0x00, 0x4F, 0x00, 0x4B, 0x00, 0x4B, 0x00, 0x48, 0x00, 0x40, 0x00, 0x62, 0x00, 0x65, 0x00, 0xF8, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xC3} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x59, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xC3} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6D, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x0C, 0x2E, 0x0E, 0xE3, 0x0E, 0x98, 0x11, 0x26, 0x10, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xE9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6D, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xE9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x00, 0x00, 0x00, 0xD4, 0x86, 0x4A, 0xC6, 0xB4, 0xC2, 0x6E, 0x2B, 0x03, 0x7C, 0x01, 0x48, 0xFD, 0xA3, 0xF6, 0x75, 0x12, 0x58, 0x2D, 0xB7, 0x00, 0x00, 0x00, 0x00, 0xCB, 0xD4, 0x1A, 0x05} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA7} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA7} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x1C, 0x98, 0x02, 0xD3, 0xFF, 0xB9, 0x30, 0xEF, 0x05, 0x11, 0x05, 0x01, 0x00, 0x00, 0x10, 0x01, 0x00, 0x3C, 0x00, 0x50, 0x3C, 0x00, 0x64, 0x3C, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x69, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x00, 0x0B, 0xD6, 0x7E, 0x74, 0x6D, 0xC6, 0x93, 0x0B, 0x0D, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xC8} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x69, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xC8} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6B, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xEF, 0x05, 0x11, 0x05, 0x01, 0x00, 0x00, 0x10, 0x01, 0x00, 0x3C, 0x00, 0x50, 0x3C, 0x00, 0x64, 0x3C, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x5B} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6B, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x5B} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x70, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xFF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x70, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xFF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x00, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x42, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 2000},
+	},
+};
+
+
diff --git a/drivers/power/supply/qcom/bq27426_gmfs_scud.h b/drivers/power/supply/qcom/bq27426_gmfs_scud.h
new file mode 100644
index 000000000000..3d47cb3dc081
--- /dev/null
+++ b/drivers/power/supply/qcom/bq27426_gmfs_scud.h
@@ -0,0 +1,970 @@
+/*****************************************************************************
+* Copyright 2010 Texas Instruments Corporation, All Rights Reserved.
+* Copyright (C) 2018 XiaoMi, Inc.
+* TI makes NO WARRANTY as to software products, which are supplied "AS-IS"
+*****************************************************************************/
+
+/*****************************************************************************
+*     This code is automatically generated from bqfs/dffs file.              *
+*          DO NOT MODIFY THIS FILE DIRECTLY                                  *
+*****************************************************************************/
+#include "bqfs_cmd_type.h"
+
+const bqfs_cmd_t bqfs_scud[] = {
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x01, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x26, 0x04} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x02, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x02, 0x02} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x13, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 1100},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x02, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x02, 0x26, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA5} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x02, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA5} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x24, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x19, 0x28, 0x63, 0x5F, 0xFF, 0x63, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x68} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x24, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x68} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x31, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x0A, 0x0F, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x31, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x40, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x64, 0x79, 0x0F, 0x86, 0x23, 0x10, 0x00, 0x14, 0x04, 0x00, 0x09, 0x04, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x0F} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x40, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x0F} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x44, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x32, 0x01, 0xC2, 0x30, 0x00, 0x03, 0x08, 0x98, 0x01, 0x00, 0x3C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x44, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x01, 0xF4, 0x00, 0x1E, 0xC8, 0x14, 0x08, 0x00, 0x3C, 0x0E, 0x10, 0x00, 0x0A, 0x46, 0x05, 0x14, 0x05, 0x0F, 0x03, 0x20, 0x7F, 0xFF, 0x00, 0xF0, 0x46, 0x50, 0x18, 0x01, 0x90, 0x00, 0x64, 0x19} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xE4} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xE4} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xDC, 0x5C, 0x60, 0x00, 0x7D, 0x00, 0x04, 0x03, 0x19, 0x25, 0x0F, 0x14, 0x0A, 0x78, 0x60, 0x28, 0x01, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x43, 0x80, 0x04, 0x01, 0x14, 0x00, 0x08, 0x0B, 0xB8, 0x01} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDB} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDB} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x02} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x2C, 0x0A, 0x01, 0x0A, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x64, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0xD0, 0x01, 0x03, 0x5A, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x59} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x02} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x59} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x51, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x01, 0x77, 0x01, 0x2C, 0x07, 0xD0, 0x00, 0x3C, 0x3C, 0x01, 0xB3, 0xB3, 0x01, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x13} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x51, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x13} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x52, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x40, 0x8A, 0x00, 0x00, 0x32, 0x81, 0x0C, 0x08, 0x2E, 0x52, 0x0C, 0x1C, 0x00, 0x64, 0x00, 0x32, 0x00, 0x14, 0x03, 0xE8, 0x01, 0x00, 0x9A, 0x00, 0x0A, 0xFF, 0xCD, 0xFF, 0xCC, 0x00, 0x02, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF3} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x52, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF3} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x15, 0x41, 0x11, 0x28, 0xD6, 0xD7, 0xDF, 0xDB, 0xE0, 0xD9, 0xDB, 0xE2, 0xEC, 0xEC, 0xE8, 0xE9, 0xE3, 0xEC, 0xF2, 0xE9, 0xE8, 0xED, 0xE5, 0xF4, 0xF0, 0xF5, 0xF7, 0xFA, 0xF9, 0xFC, 0xFB, 0xFC} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xD0} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xD0} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xF7, 0xF5, 0xF6, 0xF6, 0xF1, 0xEE, 0xF6, 0xFA, 0xFB, 0xE3, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xFA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xFA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xFA, 0xEE, 0x04, 0x45, 0x40, 0x1B, 0x3B, 0x12, 0x53, 0x4E, 0x13, 0xC8, 0xCB, 0x04, 0xF0, 0xED, 0xF0, 0xF4, 0xFE, 0xE4, 0xDC, 0xFC, 0xE9, 0x0E, 0xFE, 0xEE, 0xE7, 0xF1, 0xE3, 0xEB, 0xE2, 0x0B} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xEF, 0xF2, 0xED, 0x18, 0xD4, 0x12, 0x1D, 0x22, 0xC4, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xAF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xAF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x55, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xFF, 0x26, 0x01, 0x07, 0x08, 0xFF, 0x02, 0x12, 0x05, 0xFE, 0xFB, 0xF7, 0xFE, 0x0C, 0xDC, 0x60, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x64} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x55, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x64} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6C, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xFE, 0x78, 0x00, 0x17, 0x18, 0x09, 0xFB, 0xD3, 0xED, 0xE6, 0x04, 0x05, 0xCD, 0xD6, 0x18, 0xE4, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x10} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6C, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x10} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x59, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x46, 0x00, 0x43, 0x00, 0x44, 0x00, 0x47, 0x00, 0x44, 0x00, 0x34, 0x00, 0x36, 0x00, 0x36, 0x00, 0x3D, 0x00, 0x44, 0x00, 0x4B, 0x00, 0x56, 0x00, 0x81, 0x00, 0x7E, 0x01, 0x3C, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x59, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6D, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x0C, 0x35, 0x0E, 0xE5, 0x0E, 0xA5, 0x11, 0x26, 0x10, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xD3} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6D, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xD3} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x00, 0x00, 0x00, 0xD4, 0x86, 0x4A, 0xC6, 0xB4, 0xC2, 0x6E, 0x2B, 0x03, 0x7C, 0x01, 0x48, 0xFD, 0xA3, 0xF6, 0x75, 0x12, 0x58, 0x2D, 0xB7, 0x00, 0x00, 0x00, 0x00, 0xCB, 0xD4, 0x1A, 0x05} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA7} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA7} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x1C, 0x98, 0x02, 0xD3, 0xFF, 0xB9, 0x30, 0xEF, 0x05, 0x11, 0x05, 0x01, 0x00, 0x00, 0x10, 0x01, 0x00, 0x3C, 0x00, 0x50, 0x3C, 0x00, 0x64, 0x3C, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x69, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x01, 0x0B, 0xD6, 0x7E, 0x74, 0x6D, 0xC6, 0x93, 0x0B, 0x0D, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xC7} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x69, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xC7} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6B, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xEF, 0x05, 0x11, 0x05, 0x01, 0x00, 0x00, 0x10, 0x01, 0x00, 0x3C, 0x00, 0x50, 0x3C, 0x00, 0x64, 0x3C, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x5B} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6B, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x5B} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x70, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xFF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x70, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xFF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x00, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x42, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 2000},
+	},
+};
+
+
diff --git a/drivers/power/supply/qcom/bq27426_gmfs_sdi.h b/drivers/power/supply/qcom/bq27426_gmfs_sdi.h
new file mode 100644
index 000000000000..5e4ce5b20b09
--- /dev/null
+++ b/drivers/power/supply/qcom/bq27426_gmfs_sdi.h
@@ -0,0 +1,971 @@
+/*****************************************************************************
+* Copyright 2010 Texas Instruments Corporation, All Rights Reserved.
+* Copyright (C) 2018 XiaoMi, Inc.
+* TI makes NO WARRANTY as to software products, which are supplied "AS-IS"
+*****************************************************************************/
+
+/*****************************************************************************
+*     This code is automatically generated from bqfs/dffs file.              *
+*          DO NOT MODIFY THIS FILE DIRECTLY                                  *
+*****************************************************************************/
+
+#include "bqfs_cmd_type.h"
+
+const bqfs_cmd_t bqfs_sdi[] = {
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x01, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x26, 0x04} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x02, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x02, 0x02} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x13, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 1100},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x02, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x02, 0x26, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA5} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x02, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA5} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x24, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x19, 0x28, 0x63, 0x5F, 0xFF, 0x63, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x68} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x24, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x68} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x31, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x0A, 0x0F, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x31, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x40, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x64, 0x79, 0x0F, 0x86, 0x23, 0x10, 0x00, 0x14, 0x04, 0x00, 0x09, 0x04, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x0F} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x40, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x0F} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x44, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x32, 0x01, 0xC2, 0x30, 0x00, 0x03, 0x08, 0x98, 0x01, 0x00, 0x3C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x44, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x01, 0xF4, 0x00, 0x1E, 0xC8, 0x14, 0x08, 0x00, 0x3C, 0x0E, 0x10, 0x00, 0x0A, 0x46, 0x05, 0x14, 0x05, 0x0F, 0x03, 0x20, 0x7F, 0xFF, 0x00, 0xF0, 0x46, 0x50, 0x18, 0x01, 0x90, 0x00, 0x64, 0x19} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xE4} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xE4} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xDC, 0x5C, 0x60, 0x00, 0x7D, 0x00, 0x04, 0x03, 0x19, 0x25, 0x0F, 0x14, 0x0A, 0x78, 0x60, 0x28, 0x01, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x43, 0x80, 0x04, 0x01, 0x14, 0x00, 0x08, 0x0B, 0xB8, 0x01} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDB} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDB} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x02} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x2C, 0x0A, 0x01, 0x0A, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x64, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0xD0, 0x01, 0x03, 0x5A, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x47} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x02} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x47} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x51, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x01, 0x77, 0x01, 0x2C, 0x07, 0xD0, 0x00, 0x3C, 0x3C, 0x01, 0xB3, 0xB3, 0x01, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x13} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x51, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x13} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x52, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x42, 0x5E, 0x00, 0x00, 0x32, 0x81, 0x0C, 0x08, 0x2E, 0x52, 0x0C, 0x80, 0x00, 0x32, 0x00, 0x32, 0x00, 0x14, 0x03, 0xE8, 0x01, 0x00, 0x9A, 0x00, 0x05, 0xFF, 0xCC, 0xFF, 0xCB, 0x00, 0x02, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF2} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x52, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF2} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x16, 0x84, 0x11, 0x2B, 0xDA, 0xDC, 0xE1, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE3, 0xE8, 0xEA, 0xDF, 0xDC, 0xED, 0xED, 0xEB, 0xEB, 0xE0, 0xED, 0xEF, 0xF3, 0xF2, 0xF7, 0xF4, 0xFB, 0xF9, 0xFD, 0xFD} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x89} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x89} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xF6, 0xF8, 0xF7, 0xF5, 0xEF, 0xEA, 0xF9, 0xFB, 0xFE, 0xE1, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xFC, 0x5A, 0x05, 0x10, 0x0B, 0x00, 0x01, 0x01, 0xFF, 0xFD, 0xFC, 0x03, 0xFA, 0xFA, 0x12, 0x1D, 0xFD, 0xFD, 0x01, 0x01, 0xF1, 0xF8, 0x01, 0xFE, 0x06, 0xFB, 0x08, 0xF5, 0xFF, 0xEF, 0xEE, 0xF4} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xB7} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xB7} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xF1, 0x02, 0xFC, 0x04, 0xFF, 0x09, 0x09, 0xED, 0xA8, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xE5} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xE5} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x55, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xFF, 0x09, 0x02, 0x05, 0x05, 0x03, 0x06, 0xFE, 0x02, 0xFE, 0xFF, 0xFE, 0x00, 0x00, 0xFD, 0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x55, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6C, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xFE, 0x4B, 0x01, 0x04, 0x0D, 0x15, 0x0B, 0xE4, 0xFF, 0xE1, 0xFD, 0x00, 0xFD, 0xE9, 0x00, 0x1C, 0xBE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x03} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6C, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x03} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x59, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x4E, 0x00, 0x49, 0x00, 0x49, 0x00, 0x4D, 0x00, 0x4F, 0x00, 0x3C, 0x00, 0x42, 0x00, 0x3D, 0x00, 0x44, 0x00, 0x47, 0x00, 0x49, 0x00, 0x52, 0x00, 0x6A, 0x00, 0xA7, 0x01, 0x4F, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x41} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x59, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x41} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6D, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x0C, 0x4D, 0x0E, 0xE6, 0x0E, 0xB3, 0x11, 0x26, 0x10, 0xF9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xB1} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6D, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xB1} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x00, 0x00, 0x00, 0xD4, 0x86, 0x4A, 0xC6, 0xB4, 0xC2, 0x6E, 0x2B, 0x03, 0x7C, 0x01, 0x48, 0xFD, 0xA3, 0xF6, 0x75, 0x12, 0x58, 0x2D, 0xB7, 0x00, 0x00, 0x00, 0x00, 0xCB, 0xD4, 0x1A, 0x05} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA7} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA7} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x1C, 0x98, 0x02, 0xD3, 0xFF, 0xB9, 0x30, 0xEF, 0x05, 0x11, 0x05, 0x01, 0x00, 0x00, 0x10, 0x01, 0x00, 0x3C, 0x00, 0x50, 0x3C, 0x00, 0x64, 0x3C, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x69, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x00, 0x0B, 0xD6, 0x7E, 0x73, 0xB6, 0x45, 0x93, 0x0A, 0xA5, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xCE} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x69, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xCE} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6B, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xEF, 0x05, 0x11, 0x05, 0x01, 0x00, 0x00, 0x10, 0x01, 0x00, 0x3C, 0x00, 0x50, 0x3C, 0x00, 0x64, 0x3C, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x5B} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6B, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x5B} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x70, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xFF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x70, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xFF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x00, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x42, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 2000},
+	},
+};
+
+
diff --git a/drivers/power/supply/qcom/bq27426_gmfs_sunwoda.h b/drivers/power/supply/qcom/bq27426_gmfs_sunwoda.h
new file mode 100644
index 000000000000..14ef4f8ebec0
--- /dev/null
+++ b/drivers/power/supply/qcom/bq27426_gmfs_sunwoda.h
@@ -0,0 +1,971 @@
+/*****************************************************************************
+* Copyright 2010 Texas Instruments Corporation, All Rights Reserved.
+* Copyright (C) 2018 XiaoMi, Inc.
+* TI makes NO WARRANTY as to software products, which are supplied "AS-IS"
+*****************************************************************************/
+
+/*****************************************************************************
+*     This code is automatically generated from bqfs/dffs file.              *
+*          DO NOT MODIFY THIS FILE DIRECTLY                                  *
+*****************************************************************************/
+
+#include "bqfs_cmd_type.h"
+
+const bqfs_cmd_t bqfs_sunwoda[] = {
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x01, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x26, 0x04} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x02, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x02, 0x02} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x13, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 1100},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x02, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x02, 0x26, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA5} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x02, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA5} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x24, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x19, 0x28, 0x63, 0x5F, 0xFF, 0x63, 0x00, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x68} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x24, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x68} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x31, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x0A, 0x0F, 0x02, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x31, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x40, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x64, 0x79, 0x0F, 0x86, 0x23, 0x10, 0x00, 0x14, 0x04, 0x00, 0x09, 0x04, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x0F} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x40, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x0F} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x44, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x32, 0x01, 0xC2, 0x30, 0x00, 0x03, 0x08, 0x98, 0x01, 0x00, 0x3C, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x44, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF9} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x01, 0xF4, 0x00, 0x1E, 0xC8, 0x14, 0x08, 0x00, 0x3C, 0x0E, 0x10, 0x00, 0x0A, 0x46, 0x05, 0x14, 0x05, 0x0F, 0x03, 0x20, 0x7F, 0xFF, 0x00, 0xF0, 0x46, 0x50, 0x18, 0x01, 0x90, 0x00, 0x64, 0x19} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xE4} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xE4} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xDC, 0x5C, 0x60, 0x00, 0x7D, 0x00, 0x04, 0x03, 0x19, 0x25, 0x0F, 0x14, 0x0A, 0x78, 0x60, 0x28, 0x01, 0xF4, 0x00, 0x00, 0x00, 0x00, 0x43, 0x80, 0x04, 0x01, 0x14, 0x00, 0x08, 0x0B, 0xB8, 0x01} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDB} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xDB} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x02} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x2C, 0x0A, 0x01, 0x0A, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x64, 0x02, 0x00, 0x00, 0x00, 0x00, 0x07, 0xD0, 0x01, 0x03, 0x5A, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x59} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x50, 0x02} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x59} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x51, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x01, 0x77, 0x01, 0x2C, 0x07, 0xD0, 0x00, 0x3C, 0x3C, 0x01, 0xB3, 0xB3, 0x01, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x13} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x51, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x13} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x52, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x40, 0xEA, 0x00, 0x00, 0x32, 0x81, 0x0C, 0x08, 0x2E, 0x52, 0x0C, 0x1C, 0x00, 0xC8, 0x00, 0x32, 0x00, 0x14, 0x03, 0xE8, 0x01, 0x00, 0x9A, 0x00, 0x0A, 0xFF, 0xCD, 0xFF, 0xCC, 0x00, 0x02, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x2F} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x52, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x2F} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x15, 0x43, 0x11, 0x39, 0xDD, 0xDF, 0xDD, 0xE6, 0xDA, 0xE1, 0xE2, 0xE6, 0xE3, 0xE3, 0xE5, 0xE4, 0xDE, 0xE6, 0xEC, 0xED, 0xDD, 0xEC, 0xE9, 0xF1, 0xF3, 0xF5, 0xF5, 0xF8, 0xF8, 0xFB, 0xFC, 0xFA} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xCE} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xCE} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xF8, 0xF6, 0xF4, 0xF4, 0xF6, 0xEC, 0xFC, 0x02, 0xFA, 0xE5, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x53, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xF4, 0xE3, 0x04, 0x29, 0x17, 0x24, 0xD3, 0x42, 0x04, 0x04, 0xE1, 0x02, 0x08, 0x0D, 0x12, 0x36, 0x0F, 0x0C, 0xE0, 0xFA, 0xF9, 0x04, 0x02, 0xFE, 0xFE, 0x00, 0xFA, 0xFC, 0xED, 0xEB, 0xE8, 0xFC} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xC1} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xC1} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xFD, 0x0F, 0xF4, 0xF2, 0xE4, 0xF5, 0xD4, 0x60, 0x81, 0x81, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xFE} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x54, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xFE} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x55, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xFF, 0x84, 0x01, 0x08, 0x03, 0xFB, 0xFA, 0x11, 0x02, 0xF9, 0x00, 0xFD, 0xFF, 0xFD, 0x00, 0x1E, 0xAB, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xAD} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x55, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xAD} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6C, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xFE, 0x38, 0x00, 0x08, 0x14, 0x2C, 0xF6, 0xE7, 0x07, 0xE6, 0xF8, 0xFB, 0xF4, 0xF2, 0xF1, 0x02, 0xF3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF8} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6C, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xF8} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x59, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x3E, 0x00, 0x3A, 0x00, 0x3C, 0x00, 0x44, 0x00, 0x39, 0x00, 0x32, 0x00, 0x38, 0x00, 0x37, 0x00, 0x39, 0x00, 0x40, 0x00, 0x43, 0x00, 0x4E, 0x00, 0x5F, 0x00, 0xD4, 0x02, 0xA4, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x4A} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x59, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x4A} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6D, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x0C, 0x1D, 0x0E, 0xE3, 0x0E, 0xA4, 0x11, 0x26, 0x10, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEE} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6D, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEE} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x00, 0x00, 0x00, 0xD4, 0x86, 0x4A, 0xC6, 0xB4, 0xC2, 0x6E, 0x2B, 0x03, 0x7C, 0x01, 0x48, 0xFD, 0xA3, 0xF6, 0x75, 0x12, 0x58, 0x2D, 0xB7, 0x00, 0x00, 0x00, 0x00, 0xCB, 0xD4, 0x1A, 0x05} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA7} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xA7} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x1C, 0x98, 0x02, 0xD3, 0xFF, 0xB9, 0x30, 0xEF, 0x05, 0x11, 0x05, 0x01, 0x00, 0x00, 0x10, 0x01, 0x00, 0x3C, 0x00, 0x50, 0x3C, 0x00, 0x64, 0x3C, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x68, 0x01} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xEA} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x69, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x00, 0x00, 0x0B, 0xD6, 0x7E, 0x74, 0x6D, 0xC6, 0x93, 0x0B, 0x0D, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xC8} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x69, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xC8} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6B, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0xEF, 0x05, 0x11, 0x05, 0x01, 0x00, 0x00, 0x10, 0x01, 0x00, 0x3C, 0x00, 0x50, 0x3C, 0x00, 0x64, 0x3C, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x5B} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x6B, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0x5B} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x70, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x40,
+		.data		= {.bytes = {0x80, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} } ,
+		.data_len	= 32,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xFF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 10},
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x3E,
+		.data		= {.bytes = {0x70, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_C,
+		.addr		= 0xAA,
+		.reg		= 0x60,
+		.data		= {.bytes = {0xFF} } ,
+		.data_len	= 1,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x00, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_W,
+		.addr		= 0xAA,
+		.reg		= 0x00,
+		.data		= {.bytes = {0x42, 0x00} } ,
+		.data_len	= 2,
+	},
+	{
+		.cmd_type	= CMD_X,
+		.data		= {.delay = 2000},
+	},
+};
+
+
diff --git a/drivers/power/supply/qcom/bqfs_cmd_type.h b/drivers/power/supply/qcom/bqfs_cmd_type.h
new file mode 100644
index 000000000000..092360e73248
--- /dev/null
+++ b/drivers/power/supply/qcom/bqfs_cmd_type.h
@@ -0,0 +1,37 @@
+
+
+#ifndef __BQFS_CMD_TYPE__
+#define __BQFS_CMD_TYPE__
+
+
+#define CMD_MAX_DATA_SIZE	110
+#define RETRY_LIMIT		3
+#define CMD_RETRY_DELAY		100 /* in ms */
+
+#ifdef __GNUC__
+#define __PACKED	__attribute__((packed))
+#else
+#error "Make sure structure cmd_t is packed"
+#endif
+
+typedef enum {
+	CMD_INVALID = 0,
+	CMD_R,	/* Read */
+	CMD_W,	/* Write */
+	CMD_C,	/* Compare */
+	CMD_X,	/* Delay */
+} cmd_type_t;
+typedef struct {
+	cmd_type_t cmd_type;
+	u8 addr;
+	u8 reg;
+	union {
+		u8 bytes[CMD_MAX_DATA_SIZE + 1];
+		u16 delay;
+	} data;
+	u8  data_len;
+	u16 line_num;
+} __PACKED bqfs_cmd_t;
+
+
+#endif
diff --git a/drivers/power/supply/qcom/qpnp-fg.c b/drivers/power/supply/qcom/qpnp-fg.c
index 7df1f062db43..386ef3f8e9a5 100644
--- a/drivers/power/supply/qcom/qpnp-fg.c
+++ b/drivers/power/supply/qcom/qpnp-fg.c
@@ -2026,10 +2026,10 @@ static void fg_handle_battery_insertion(struct fg_chip *chip)
 }
 
 
-static int soc_to_setpoint(int soc)
+/*static int soc_to_setpoint(int soc)
 {
 	return DIV_ROUND_CLOSEST(soc * 255, 100);
-}
+}*/
 
 static void batt_to_setpoint_adc(int vbatt_mv, u8 *data)
 {
@@ -2255,10 +2255,20 @@ static int get_prop_capacity(struct fg_chip *chip)
 				FULL_SOC_RAW - 2) + 1;
 	}
 
-	if (chip->battery_missing)
-		return MISSING_CAPACITY;
-	if (!chip->profile_loaded && !chip->use_otp_profile)
-		return DEFAULT_CAPACITY;
+	if (chip->battery_missing) {
+		msoc = get_monotonic_soc_raw(chip);
+		return DIV_ROUND_CLOSEST((msoc - 1) * (FULL_CAPACITY - 2),
+			FULL_SOC_RAW - 2) + 1;
+	}
+	if (!chip->profile_loaded && !chip->use_otp_profile) {
+
+		msoc = get_monotonic_soc_raw(chip);
+		if (msoc == FULL_SOC_RAW) {
+			return FULL_CAPACITY;
+		}
+		return DIV_ROUND_CLOSEST((msoc - 1) * (FULL_CAPACITY - 2),
+			FULL_SOC_RAW - 2) + 1;
+	}
 	if (chip->charge_full)
 		return FULL_CAPACITY;
 	if (chip->soc_empty) {
@@ -4562,6 +4572,30 @@ static enum power_supply_property fg_power_props[] = {
 	POWER_SUPPLY_PROP_BATTERY_INFO_ID,
 };
 
+static int update_sram_current(struct fg_chip *chip)
+{
+	int cur=0;
+	int rc=0;
+	u8 reg[4];
+	int64_t temp=0;
+
+	fg_stay_awake(&chip->update_sram_wakeup_source);
+	fg_mem_lock(chip);
+	rc = fg_mem_read(chip,reg,0x5CC,2,3,0);
+	if(rc) {
+		pr_err("Failed to update current sram data\n");
+		return rc;
+	}
+
+	temp=reg[0];
+	temp|=reg[1]<<8;
+	temp=twos_compliment_extend(temp,2);
+	cur=div_s64((s64)temp * LSB_16B_NUMRTR,LSB_16B_DENMTR);
+	fg_mem_release(chip);
+	fg_relax(&chip->update_sram_wakeup_source);
+	return cur;
+}
+
 static int fg_power_get_property(struct power_supply *psy,
 				       enum power_supply_property psp,
 				       union power_supply_propval *val)
@@ -4588,7 +4622,7 @@ static int fg_power_get_property(struct power_supply *psy,
 		val->intval = get_sram_prop_now(chip, FG_DATA_VINT_ERR);
 		break;
 	case POWER_SUPPLY_PROP_CURRENT_NOW:
-		val->intval = get_sram_prop_now(chip, FG_DATA_CURRENT);
+		val->intval = update_sram_current(chip);
 		break;
 	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
 		val->intval = get_sram_prop_now(chip, FG_DATA_VOLTAGE);
@@ -4633,7 +4667,7 @@ static int fg_power_get_property(struct power_supply *psy,
 			val->intval = 1;
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
-		val->intval = chip->nom_cap_uah;
+		val->intval = 3080;
 		break;
 	case POWER_SUPPLY_PROP_CHARGE_FULL:
 		val->intval = chip->learning_data.learned_cc_uah;
@@ -5410,6 +5444,14 @@ static irqreturn_t fg_soc_irq_handler(int irq, void *_chip)
 		fg_stay_awake(&chip->esr_extract_wakeup_source);
 		schedule_work(&chip->esr_extract_config_work);
 	}
+	printk("%s, capacity=%d, current=%d, chg_status=%d, usb_present=%d, voltage=%d, batt_temp=%d, batt_id=%d\n", __func__,
+		get_prop_capacity(chip),
+		get_sram_prop_now(chip, FG_DATA_CURRENT),
+		chip->status,
+		is_usb_present(chip),
+		get_sram_prop_now(chip, FG_DATA_VOLTAGE),
+		get_sram_prop_now(chip, FG_DATA_BATT_TEMP),
+		get_sram_prop_now(chip, FG_DATA_BATT_ID));
 
 	return IRQ_HANDLED;
 }
@@ -6405,6 +6447,23 @@ static int fg_batt_profile_init(struct fg_chip *chip)
 				&chip->cc_cv_threshold_mv);
 	}
 
+	if (!of_find_property(chip->spmi->dev.of_node,
+				"qcom,thermal-coefficients", NULL)) {
+		data = of_get_property(profile_node,
+				"qcom,thermal-coefficients", &len);
+		if (data && len == THERMAL_COEFF_N_BYTES) {
+			memcpy(chip->thermal_coefficients, data, len);
+			rc = fg_mem_write(chip, chip->thermal_coefficients,
+				THERMAL_COEFF_ADDR, THERMAL_COEFF_N_BYTES,
+				THERMAL_COEFF_OFFSET, 0);
+			if (rc)
+				pr_err("chen spmi write failed addr:%03x, ret:%d\n",
+						THERMAL_COEFF_ADDR, rc);
+			else if (fg_debug_mask & FG_STATUS)
+				pr_info("chen Battery thermal coefficients changed\n");
+		}
+	}
+
 	data = of_get_property(profile_node, "qcom,fg-profile-data", &len);
 	if (!data) {
 		pr_err("no battery profile loaded\n");
@@ -6572,8 +6631,8 @@ static int fg_batt_profile_init(struct fg_chip *chip)
 	if (chip->power_supply_registered)
 		power_supply_changed(chip->bms_psy);
 	fg_relax(&chip->profile_wakeup_source);
-	pr_info("Battery SOC: %d, V: %duV\n", get_prop_capacity(chip),
-		fg_data[FG_DATA_VOLTAGE].value);
+	pr_info("Battery SOC: %d, V: %duV batt_id %d\n", get_prop_capacity(chip),
+		fg_data[FG_DATA_VOLTAGE].value,get_sram_prop_now(chip, FG_DATA_BATT_ID));
 	complete_all(&chip->fg_reset_done);
 	return rc;
 no_profile:
@@ -8033,7 +8092,7 @@ static int fg_common_hw_init(struct fg_chip *chip)
 	}
 
 	rc = fg_mem_masked_write(chip, settings[FG_MEM_DELTA_SOC].address, 0xFF,
-			soc_to_setpoint(settings[FG_MEM_DELTA_SOC].value),
+			settings[FG_MEM_DELTA_SOC].value,
 			settings[FG_MEM_DELTA_SOC].offset);
 	if (rc) {
 		pr_err("failed to write delta soc rc=%d\n", rc);
diff --git a/drivers/power/supply/qcom/qpnp-smbcharger.c b/drivers/power/supply/qcom/qpnp-smbcharger.c
index 391cfbf64ead..c6a6aeceac29 100644
--- a/drivers/power/supply/qcom/qpnp-smbcharger.c
+++ b/drivers/power/supply/qcom/qpnp-smbcharger.c
@@ -121,6 +121,7 @@ struct smbchg_chip {
 	int				dc_target_current_ma;
 	int				cfg_fastchg_current_ma;
 	int				fastchg_current_ma;
+	int				battery_full_design;
 	int				vfloat_mv;
 	int				fastchg_current_comp;
 	int				float_voltage_comp;
@@ -289,6 +290,7 @@ struct smbchg_chip {
 	struct votable			*hw_aicl_rerun_enable_indirect_votable;
 	struct votable			*aicl_deglitch_short_votable;
 	struct votable			*hvdcp_enable_votable;
+	struct regulator* 		ntc_vdd;
 	/* extcon for VBUS / ID notification to USB */
 	struct extcon_dev		*extcon;
 };
@@ -448,7 +450,7 @@ module_param_named(
 	int, 00600
 );
 
-static int smbchg_default_hvdcp_icl_ma = 1800;
+static int smbchg_default_hvdcp_icl_ma = 2000;
 module_param_named(
 	default_hvdcp_icl_ma, smbchg_default_hvdcp_icl_ma,
 	int, 00600
@@ -460,7 +462,7 @@ module_param_named(
 	int, 00600
 );
 
-static int smbchg_default_dcp_icl_ma = 1800;
+static int smbchg_default_dcp_icl_ma = 2000;
 module_param_named(
 	default_dcp_icl_ma, smbchg_default_dcp_icl_ma,
 	int, 00600
@@ -4157,7 +4159,7 @@ static int smbchg_register_chg_led(struct smbchg_chip *chip)
 {
 	int rc;
 
-	chip->led_cdev.name = "red";
+	chip->led_cdev.name = "smbchg_red";
 	chip->led_cdev.brightness_set = smbchg_chg_led_brightness_set;
 	chip->led_cdev.brightness_get = smbchg_chg_led_brightness_get;
 
@@ -5906,6 +5908,105 @@ static int smbchg_get_iusb(struct smbchg_chip *chip)
 	return iusb_ua;
 }
 
+static int BatteryTestStatus_enable = 0;
+
+static ssize_t smb_battery_test_status_show(struct device *dev,
+					struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", BatteryTestStatus_enable);
+}
+
+static ssize_t smb_battery_test_status_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int retval;
+	unsigned int input;
+
+	if (sscanf(buf, "%u", &input) != 1) {
+		retval = -EINVAL;
+		BatteryTestStatus_enable = 0;
+		goto exit;
+	}
+	if (input != 1) {
+		retval = -EINVAL;
+		BatteryTestStatus_enable = 0;
+		goto exit;
+	}
+	BatteryTestStatus_enable = 1;
+exit:
+	return retval;
+}
+static struct device_attribute attrs[] = {
+	__ATTR(BatteryTestStatus, S_IRUGO | S_IWUSR | S_IWGRP,
+			smb_battery_test_status_show,
+			smb_battery_test_status_store),
+
+};
+bool is_oldtest = false;
+void runin_work(struct smbchg_chip *chip, int batt_capacity)
+{
+	int rc;
+	if (!is_usb_present(chip) || !BatteryTestStatus_enable) {
+		if(is_oldtest) {
+			rc = smbchg_usb_suspend(chip,false);
+			if (rc)
+				dev_err(chip->dev,"Couldn't enable charge rc=%d\n", rc);
+			is_oldtest = false;
+		}
+		return;
+	}
+	is_oldtest = true;
+	pr_info("%s:BatteryTestStatus_enable = %d chip->usb_present = %d \n",__func__,BatteryTestStatus_enable,chip->usb_present);
+	if (batt_capacity > 80) {
+		pr_debug("smbcharge_get_prop_batt_capacity > 80\n");
+		rc = smbchg_usb_suspend(chip,true);
+		if (rc)
+			dev_err(chip->dev,
+				"Couldn't disenable charge rc=%d\n", rc);
+	} else {
+		if (batt_capacity < 60) {
+		pr_debug("smbcharge_get_prop_batt_capacity < 60\n");
+		rc = smbchg_usb_suspend(chip,false);
+		if (rc)
+			dev_err(chip->dev,
+				"Couldn't enable charge rc=%d\n", rc);
+		}
+	}
+}
+int ntc_regulator_init(struct smbchg_chip* chip)
+{
+	int rc;
+
+	chip->ntc_vdd = regulator_get(chip->dev, "ntc_vdd");
+	if (IS_ERR(chip->ntc_vdd)) {
+		rc = PTR_ERR(chip->ntc_vdd);
+		pr_err("ntc_regulator_init err.\n");
+		return rc;
+	}
+
+	if (regulator_count_voltages(chip->ntc_vdd ) > 0) {
+		rc = regulator_set_voltage(chip->ntc_vdd , 1800000,1800000);
+		if (rc) {
+			pr_err("ntc_regulator_init 1.8  error.\n");
+			goto deinit_vregs;
+		}
+	}
+	if (!IS_ERR_OR_NULL(chip->ntc_vdd)) {
+		rc = regulator_enable(chip->ntc_vdd);
+		if (rc) {
+			pr_err("ntc_regulator_init enable failed.\n");
+			regulator_disable(chip->ntc_vdd);
+		}
+	}
+	pr_err("ntc_regulator_init end .\n");
+	return 0;
+deinit_vregs:
+	pr_err("regualtor init 1.8 failed.\n");
+	if (regulator_count_voltages(chip->ntc_vdd) > 0)
+		regulator_set_voltage(chip->ntc_vdd, 0, 1800000);
+	return rc;
+}
+
 static enum power_supply_property smbchg_battery_properties[] = {
 	POWER_SUPPLY_PROP_STATUS,
 	POWER_SUPPLY_PROP_PRESENT,
@@ -5926,6 +6027,7 @@ static enum power_supply_property smbchg_battery_properties[] = {
 	POWER_SUPPLY_PROP_VOLTAGE_NOW,
 	POWER_SUPPLY_PROP_RESISTANCE_ID,
 	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN,
 	POWER_SUPPLY_PROP_SAFETY_TIMER_ENABLE,
 	POWER_SUPPLY_PROP_INPUT_CURRENT_MAX,
 	POWER_SUPPLY_PROP_INPUT_CURRENT_SETTLED,
@@ -6115,6 +6217,7 @@ static int smbchg_battery_get_property(struct power_supply *psy,
 	/* properties from fg */
 	case POWER_SUPPLY_PROP_CAPACITY:
 		val->intval = get_prop_batt_capacity(chip);
+		runin_work(chip, val->intval);
 		break;
 	case POWER_SUPPLY_PROP_CURRENT_NOW:
 		val->intval = get_prop_batt_current_now(chip);
@@ -6129,6 +6232,9 @@ static int smbchg_battery_get_property(struct power_supply *psy,
 	case POWER_SUPPLY_PROP_CHARGE_FULL:
 		val->intval = get_prop_batt_full_charge(chip);
 		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN:
+		val->intval = chip->battery_full_design;
+		break;
 	case POWER_SUPPLY_PROP_TEMP:
 		val->intval = get_prop_batt_temp(chip);
 		break;
@@ -6270,7 +6376,7 @@ static irqreturn_t batt_hot_handler(int irq, void *_chip)
 
 	smbchg_read(chip, &reg, chip->bat_if_base + RT_STS, 1);
 	chip->batt_hot = !!(reg & HOT_BAT_HARD_BIT);
-	pr_smb(PR_INTERRUPT, "triggered: 0x%02x\n", reg);
+	pr_err("batt_hot_handler triggered: 0x%02x\n", reg);
 	smbchg_parallel_usb_check_ok(chip);
 	if (chip->batt_psy)
 		power_supply_changed(chip->batt_psy);
@@ -6288,7 +6394,7 @@ static irqreturn_t batt_cold_handler(int irq, void *_chip)
 
 	smbchg_read(chip, &reg, chip->bat_if_base + RT_STS, 1);
 	chip->batt_cold = !!(reg & COLD_BAT_HARD_BIT);
-	pr_smb(PR_INTERRUPT, "triggered: 0x%02x\n", reg);
+	pr_err("batt_cold_handler triggered: 0x%02x\n", reg);
 	smbchg_parallel_usb_check_ok(chip);
 	if (chip->batt_psy)
 		power_supply_changed(chip->batt_psy);
@@ -6303,10 +6409,29 @@ static irqreturn_t batt_warm_handler(int irq, void *_chip)
 {
 	struct smbchg_chip *chip = _chip;
 	u8 reg = 0;
+	int rc;
 
 	smbchg_read(chip, &reg, chip->bat_if_base + RT_STS, 1);
 	chip->batt_warm = !!(reg & HOT_BAT_SOFT_BIT);
-	pr_smb(PR_INTERRUPT, "triggered: 0x%02x\n", reg);
+	pr_err("batt_warm_handler triggered: 0x%02x\n", reg);
+	if(chip->batt_warm)
+	{
+
+		rc = smbchg_float_voltage_comp_set(chip,chip->float_voltage_comp);
+		if (rc < 0) {
+			dev_err(chip->dev, "Couldn't set float voltage comp rc = %d\n",rc);
+		}
+
+		rc = smbchg_fastchg_current_comp_set(chip,chip->fastchg_current_comp);
+		if (rc < 0) {
+		dev_err(chip->dev, "Couldn't set fastchg current comp rc = %d\n",rc);
+		}
+	} else{
+		rc = smbchg_float_voltage_comp_set(chip,0x0);
+		if (rc < 0) {
+			dev_err(chip->dev, "Couldn't set float voltage  comp rc = %d\n",rc);
+		}
+	}
 	smbchg_parallel_usb_check_ok(chip);
 	if (chip->batt_psy)
 		power_supply_changed(chip->batt_psy);
@@ -6319,10 +6444,30 @@ static irqreturn_t batt_cool_handler(int irq, void *_chip)
 {
 	struct smbchg_chip *chip = _chip;
 	u8 reg = 0;
+	int rc;
 
 	smbchg_read(chip, &reg, chip->bat_if_base + RT_STS, 1);
 	chip->batt_cool = !!(reg & COLD_BAT_SOFT_BIT);
-	pr_smb(PR_INTERRUPT, "triggered: 0x%02x\n", reg);
+	pr_err("batt_cool_handler triggered: 0x%02x\n", reg);
+	if(chip->batt_cool) {
+
+		rc = smbchg_float_voltage_comp_set(chip,0x0);
+		if (rc < 0) {
+			dev_err(chip->dev, "Couldn't set float voltage  comp rc = %d\n",rc);
+		}
+
+
+		rc = smbchg_fastchg_current_comp_set(chip,chip->fastchg_current_comp);
+		if (rc < 0) {
+		dev_err(chip->dev, "Couldn't set fastchg current comp rc = %d\n",rc);
+		}
+	} else{
+
+		rc = smbchg_float_voltage_comp_set(chip,chip->float_voltage_comp);
+		if (rc < 0) {
+			dev_err(chip->dev, "Couldn't set float voltage comp rc = %d\n",rc);
+		}
+	}
 	smbchg_parallel_usb_check_ok(chip);
 	if (chip->batt_psy)
 		power_supply_changed(chip->batt_psy);
@@ -7528,6 +7673,7 @@ static int smb_parse_wipower_dt(struct smbchg_chip *chip)
 #define DEFAULT_VLED_MAX_UV		3500000
 #define DEFAULT_FCC_MA			2000
 #define DEFAULT_NUM_OF_PULSE_ALLOWED	20
+#define DEFAULT_BATTERY_FULL_DESIGN     3080
 static int smb_parse_dt(struct smbchg_chip *chip)
 {
 	int rc = 0, ocp_thresh = -EINVAL;
@@ -7549,6 +7695,10 @@ static int smb_parse_dt(struct smbchg_chip *chip)
 			"fastchg-current-ma", rc, 1);
 	if (chip->cfg_fastchg_current_ma == -EINVAL)
 		chip->cfg_fastchg_current_ma = DEFAULT_FCC_MA;
+	OF_PROP_READ(chip, chip->battery_full_design,
+			"battery-full-design", rc, 1);
+	if (chip->battery_full_design == -EINVAL)
+		chip->battery_full_design = DEFAULT_BATTERY_FULL_DESIGN;
 	OF_PROP_READ(chip, chip->vfloat_mv, "float-voltage-mv", rc, 1);
 	OF_PROP_READ(chip, chip->safety_time, "charging-timeout-mins", rc, 1);
 	OF_PROP_READ(chip, chip->vled_max_uv, "vled-max-uv", rc, 1);
@@ -8470,6 +8620,7 @@ static int smbchg_probe(struct platform_device *pdev)
 		goto votables_cleanup;
 	}
 
+	rc = ntc_regulator_init(chip);
 	rc = smbchg_hw_init(chip);
 	if (rc < 0) {
 		dev_err(&pdev->dev,
@@ -8563,6 +8714,13 @@ static int smbchg_probe(struct platform_device *pdev)
 	update_usb_status(chip, is_usb_present(chip), false);
 	dump_regs(chip);
 	create_debugfs_entries(chip);
+	rc = sysfs_create_file(&chip->dev->kobj,&attrs[0].attr);
+	if (rc < 0) {
+		dev_err(chip->dev,
+				"%s: Failed to create sysfs attributes\n",
+				__func__);
+		 sysfs_remove_file(&chip->dev->kobj,&attrs[0].attr);
+	}
 	dev_info(chip->dev,
 		"SMBCHG successfully probe Charger version=%s Revision DIG:%d.%d ANA:%d.%d batt=%d dc=%d usb=%d\n",
 			version_str[chip->schg_version],
diff --git a/drivers/power/supply/qcom/qpnp-typec.c b/drivers/power/supply/qcom/qpnp-typec.c
index 12aa16b0b96c..21a42f4966d5 100644
--- a/drivers/power/supply/qcom/qpnp-typec.c
+++ b/drivers/power/supply/qcom/qpnp-typec.c
@@ -13,6 +13,15 @@
  */
 #define pr_fmt(fmt)	"TYPEC: %s: " fmt, __func__
 
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/fs.h>
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
 #include <linux/bitops.h>
 #include <linux/err.h>
 #include <linux/gpio.h>
@@ -866,6 +875,83 @@ static int qpnp_typec_dr_get_property(struct dual_role_phy_instance *dual_role,
 	return 0;
 }
 
+struct qpnp_typec_chip *ro_chip;
+static struct proc_dir_entry *proc_root;
+static struct proc_dir_entry *proc_entry;
+
+#define USER_ROOT_DIR "usb"
+#define INTERPOLATION_DIR "interpolation"
+
+static int proc_interpolation_show(struct seq_file *m, void *v)
+{
+	u8 rc,reg;
+
+	if(!ro_chip)
+		return -1;
+
+	if(ro_chip->typec_state == POWER_SUPPLY_TYPE_UNKNOWN) {
+		seq_printf(m,"0\n");
+		return 0;
+	}
+	rc = qpnp_typec_read(ro_chip, &reg, TYPEC_UFP_STATUS_REG(ro_chip->base), 1);
+	if (rc) {
+		pr_err("failed to read status reg rc=%d\n", rc);
+		return -1;
+	}
+
+	printk("<lsy>the 0xbf08 : 0x%x",reg);
+
+	if(reg & 0x80)
+		seq_printf(m,"1\n");
+	else
+		seq_printf(m,"2\n");
+
+
+	return 0;
+}
+
+static int proc_interpolation_open(struct inode *inode, struct file *file)
+{
+	return single_open(file,proc_interpolation_show,NULL);
+}
+
+static const struct file_operations interpolation_proc_fops = {
+.owner = THIS_MODULE,
+.open = proc_interpolation_open,
+.read = seq_read,
+.llseek = seq_lseek,
+.release = single_release,
+};
+
+static int interpolation_create_proc_entry(void)
+{
+	int error = 0;
+	proc_root = proc_mkdir(USER_ROOT_DIR, NULL);
+	if (NULL==proc_root) {
+		printk(KERN_ALERT"Create dir /proc/%s error!\n", USER_ROOT_DIR);
+		return -ENOMEM;
+	}
+	printk(KERN_INFO"Create dir /proc/%s\n", USER_ROOT_DIR);
+
+	proc_entry = proc_create(INTERPOLATION_DIR, 0444, proc_root, &interpolation_proc_fops);
+	if (NULL ==proc_entry)
+	{
+		printk(KERN_ALERT"Create entry %s under /proc/%s error!\n", INTERPOLATION_DIR,USER_ROOT_DIR);
+		error = -ENOMEM;
+		goto err_out;
+
+	}
+
+	printk(KERN_INFO"Create /proc/%s/%s\n", USER_ROOT_DIR,INTERPOLATION_DIR);
+
+	return 0;
+err_out:
+
+	remove_proc_entry(INTERPOLATION_DIR, proc_root);
+	remove_proc_entry(USER_ROOT_DIR, NULL);
+	return error;
+}
+
 static int qpnp_typec_probe(struct platform_device *pdev)
 {
 	int rc;
@@ -891,6 +977,7 @@ static int qpnp_typec_probe(struct platform_device *pdev)
 		return -EINVAL;
 	}
 
+	ro_chip = chip;
 	chip->dev = &pdev->dev;
 
 	/* parse DT */
@@ -964,6 +1051,7 @@ static int qpnp_typec_probe(struct platform_device *pdev)
 
 	pr_info("TypeC successfully probed state=%d CC-line-state=%d\n",
 			chip->typec_state, chip->cc_line_state);
+	interpolation_create_proc_entry();
 	return 0;
 
 unregister_psy:
@@ -990,6 +1078,8 @@ static int qpnp_typec_remove(struct platform_device *pdev)
 
 	mutex_destroy(&chip->typec_lock);
 	dev_set_drvdata(chip->dev, NULL);
+	remove_proc_entry(INTERPOLATION_DIR, proc_root);
+	remove_proc_entry(USER_ROOT_DIR, NULL);
 
 	return 0;
 }
-- 
2.20.1

